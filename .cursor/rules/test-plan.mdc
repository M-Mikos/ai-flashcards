---
description:
globs:
alwaysApply: false
---

Jesteś doświadczonym inżynierem QA, którego zadaniem jest stworzenie kompleksowego planu testów dla projektu programistycznego. Przeanalizuj poniższe informacje o projekcie:

<struktura_katalogów>
Directory structure:
└── src/
├── env.d.ts
├── types.ts
├── components/
│ ├── Welcome.astro
│ ├── account/
│ │ ├── AccountPage.tsx
│ │ ├── ConfirmationDialog.tsx
│ │ ├── DangerZoneCard.tsx
│ │ ├── LogoutButton.tsx
│ │ ├── ProfileCard.tsx
│ │ └── ThemeToggle.tsx
│ ├── auth/
│ │ ├── AuthCard.tsx
│ │ ├── FormField.tsx
│ │ ├── LoginForm.tsx
│ │ ├── PasswordRequirementList.tsx
│ │ ├── RegisterForm.tsx
│ │ ├── ResetConfirmForm.tsx
│ │ └── ResetRequestForm.tsx
│ ├── flashcards/
│ │ └── MyFlashcardsView.tsx
│ ├── generate/
│ │ ├── GeneratePage.tsx
│ │ ├── Step1Input.tsx
│ │ ├── Step2Proposals.tsx
│ │ └── types.ts
│ ├── hooks/
│ │ ├── useCharacterCounter.ts
│ │ ├── useFlashcardsList.ts
│ │ ├── useGenerateState.ts
│ │ └── useThemeMode.ts
│ ├── learning/
│ │ ├── HotkeyHandler.tsx
│ │ ├── LearningCard.tsx
│ │ ├── LearningSession.tsx
│ │ ├── ProgressCounter.tsx
│ │ ├── ScoreButtons.tsx
│ │ └── SummaryModal.tsx
│ ├── navigation/
│ │ └── SiteNavigation.astro
│ └── ui/
│ └── button.tsx
├── db/
│ ├── database.types.ts
│ └── supabase.client.ts
├── layouts/
│ ├── AuthLayout.astro
│ └── Layout.astro
├── lib/
│ ├── utils.ts
│ ├── api/
│ │ ├── flashcards.client.ts
│ │ └── generations.client.ts
│ ├── hooks/
│ │ ├── useHotkeys.ts
│ │ └── useLearningSession.ts
│ ├── services/
│ │ ├── flashcards.ts
│ │ ├── generations.ts
│ │ ├── learning.ts
│ │ └── openrouter.ts
│ ├── validation/
│ │ └── authSchemas.ts
│ └── view-models/
│ └── flashcards.ts
├── middleware/
│ └── index.ts
├── pages/
│ ├── account.astro
│ ├── generate.astro
│ ├── index.astro
│ ├── learn.astro
│ ├── api/
│ │ ├── flashcards.ts
│ │ ├── generations.ts
│ │ ├── auth/
│ │ │ ├── login.ts
│ │ │ ├── logout.ts
│ │ │ ├── register.ts
│ │ │ ├── reset.ts
│ │ │ └── reset/
│ │ │ └── confirm.ts
│ │ ├── flashcards/
│ │ │ ├── [id].ts
│ │ │ └── bulk.ts
│ │ └── learning/
│ │ └── session.ts
│ └── auth/
│ ├── login.astro
│ ├── register.astro
│ ├── reset.astro
│ └── reset/
│ └── confirm.astro
└── styles/
└── global.css
</struktura_katalogów>

# <kod_projektu>

# FILE: src/env.d.ts

/// <reference types="astro/client" />

import type { SupabaseClient } from "./db/supabase.client.ts";

declare global {
namespace App {
interface Locals {
supabase: SupabaseClient;
user?: {
id: string;
email: string | null;
};
}
}
}

interface ImportMetaEnv {
readonly SUPABASE_URL: string;
readonly SUPABASE_KEY: string;
readonly SUPABASE_SERVICE_ROLE_KEY: string;
readonly OPENROUTER_API_KEY?: string;
readonly OPENROUTER_BASE_URL?: string;
readonly PUBLIC_APP_URL?: string;
}

interface ImportMeta {
readonly env: ImportMetaEnv;
}

================================================
FILE: src/types.ts
================================================
import type { ReactNode } from "react";

import type { Enums, Tables } from "./db/database.types";

/\*\*

- Shared pagination envelope used by list endpoints.
  \*/
  export interface PaginatedResponse<T> {
  items: T[];
  page: number;
  pageSize: number;
  total: number;
  }

type GenerationRow = Tables<"generations">;
type FlashcardRow = Tables<"flashcards">;
export type SourceEnum = Enums<"source_enum">;

/\*\*

- Outbound generation representation (camelCase) derived from the DB row.
- Keeping fields mapped to DB types ensures drift is caught by the compiler.
  \*/
  export interface GenerationDTO {
  id: GenerationRow["id"];
  hash: GenerationRow["hash"];
  userId: GenerationRow["user_id"];
  modelName: GenerationRow["model_name"];
  inputLength: GenerationRow["input_length"];
  generatedCount: GenerationRow["generated_count"];
  acceptedCount: GenerationRow["accepted_count"];
  acceptedEditedCount: GenerationRow["accepted_edited_count"];
  generationTimeMs: GenerationRow["generation_time_ms"];
  createdAt: GenerationRow["created_at"];
  updatedAt: GenerationRow["updated_at"];
  }

/\*\*

- Request body for POST /api/generations.
  \*/
  export interface CreateGenerationCommand {
  text: string;
  model: "gpt-4o-mini";
  }

/\*\*

- Minimal response after generation creation.
  \*/
  export type GenerationCreateResponse = Pick<
  GenerationDTO,
  "id" | "hash" | "inputLength" | "generatedCount" | "createdAt"
  > ;

/\*\*

- Flashcard proposal produced during generation.
  \*/
  export type GeneratedFlashcard = Pick<FlashcardRow, "front" | "back" | "source">;

/\*\*

- Complete response for POST /api/generations including flashcard proposals.
  \*/
  export interface GenerationCreateWithFlashcardsResponse {
  generation: GenerationCreateResponse;
  flashcards: GeneratedFlashcard[];
  }

export interface GenerationListQuery {
page?: number;
pageSize?: number;
sort?: "created_at desc" | "created_at asc";
}

export type GenerationListResponse = PaginatedResponse<GenerationDTO>;
export type GenerationDetailResponse = GenerationDTO;

/\*\*

- Outbound flashcard representation (camelCase) derived from the DB row.
- userId is intentionally omitted in outward DTOs.
  \*/
  export interface FlashcardDTO {
  id: FlashcardRow["id"];
  front: FlashcardRow["front"];
  back: FlashcardRow["back"];
  source: FlashcardRow["source"];
  generationId: FlashcardRow["generation_id"];
  createdAt: FlashcardRow["created_at"];
  updatedAt: FlashcardRow["updated_at"];
  }

/\*\*

- Request body for POST /api/flashcards.
  \*/
  export interface CreateFlashcardCommand {
  front: FlashcardRow["front"];
  back: FlashcardRow["back"];
  source: SourceEnum;
  generationId: FlashcardRow["generation_id"];
  }

/\*\*

- Request body for PATCH /api/flashcards/:id (partial update).
  \*/
  export type UpdateFlashcardCommand = Partial<Pick<CreateFlashcardCommand, "front" | "back" | "source">>;

export type FlashcardCreateResponse = Pick<
FlashcardDTO,
"id" | "front" | "back" | "source" | "generationId" | "createdAt"

> ;
> export type FlashcardUpdateResponse = FlashcardDTO;
> export type FlashcardDetailResponse = FlashcardDTO;

export interface FlashcardListQuery {
page?: number;
pageSize?: number;
source?: SourceEnum;
generationId?: FlashcardRow["generation_id"];
sort?: "created_at desc" | "created_at asc";
}

export type FlashcardListResponse = PaginatedResponse<FlashcardDTO>;

/\*\*

- Request body for POST /api/flashcards/bulk.
  \*/
  export interface BulkCreateFlashcardsCommand {
  generationId: FlashcardRow["generation_id"];
  flashcards: Omit<CreateFlashcardCommand, "generationId">[];
  }

export interface BulkCreateFlashcardsResponse {
created: number;
ids: FlashcardRow["id"][];
}

/\*\*

- Request body for POST /api/learning/session.
  \*/
  export interface LearningSessionCommand {
  count?: number;
  source?: SourceEnum;
  generationId?: FlashcardRow["generation_id"];
  }

export type LearningSessionCard = Pick<FlashcardDTO, "id" | "front" | "back">;

export interface LearningSessionResponse {
cards: LearningSessionCard[];
}

export type Grade = 0 | 1 | 2 | 3 | 4 | 5;

export interface LearningCardVM extends LearningSessionCard {
flipped: boolean;
grade?: Grade;
}

export interface LearningSessionVM {
cards: LearningCardVM[];
currentIndex: number;
finished: boolean;
}

export interface SessionStats {
avgGrade: number;
total: number;
}

/\*\*

- Request body for POST /api/learning/feedback.
  \*/
  export interface LearningFeedbackCommand {
  cardId: FlashcardRow["id"];
  grade: number;
  timestamp: string;
  }

export type ThemeMode = "light" | "dark" | "system";

export interface ThemeState {
mode: ThemeMode;
isSystemPreferredDark: boolean;
}

export interface AccountViewModel {
email: string;
}

export interface DeleteAccountState {
isOpen: boolean;
confirmationText: string;
isDeleting: boolean;
}

export interface ConfirmDialogProps {
open: boolean;
loading?: boolean;
confirmDisabled?: boolean;
children?: ReactNode;
title: string;
description?: string;
confirmLabel?: string;
onConfirm: () => void;
onOpenChange: (open: boolean) => void;
}

export interface LogoutState {
isLoggingOut: boolean;
}

export type LlmRole = "system" | "user" | "assistant";

export interface OpenRouterMessage {
role: LlmRole;
content: string;
}

export interface JsonSchemaFormat {
type: "json_schema";
json_schema: {
name: string;
schema: Record<string, unknown>;
strict?: boolean;
description?: string;
};
}

export type ResponseFormat = JsonSchemaFormat;

export interface SendChatOptions {
model?: string;
temperature?: number;
max_tokens?: number;
response_format?: ResponseFormat;
abortSignal?: AbortSignal;
}

export interface OpenRouterConfig {
apiKey: string;
baseUrl: string;
timeoutMs: number;
maxRetries: number;
rateLimitQPS: number;
defaultModel: string;
}

export interface OpenRouterChoice {
index: number;
message: OpenRouterMessage;
finish_reason?: string | null;
}

export interface OpenRouterUsage {
prompt_tokens?: number;
completion_tokens?: number;
total_tokens?: number;
}

export interface OpenRouterReply {
id: string;
created: number;
model: string;
choices: OpenRouterChoice[];
usage?: OpenRouterUsage;
}

export interface ParsedReply {
raw: OpenRouterReply;
message: OpenRouterMessage;
content: string;
json?: unknown;
}

================================================
FILE: src/components/Welcome.astro
================================================

<div
  class="relative w-full mx-auto min-h-screen bg-gradient-to-br from-indigo-900 via-purple-900 to-blue-900 p-4 sm:p-8"
>
  <div
    class="relative max-w-4xl mx-auto backdrop-blur-xl bg-gradient-to-b from-white/10 to-white/5 rounded-2xl shadow-2xl p-8 text-white border border-white/10"
  >
    <div class="space-y-8">
      <div class="text-center">
        <h1
          class="text-6xl font-bold mb-4 bg-gradient-to-r from-blue-200 via-purple-200 to-pink-200 text-transparent bg-clip-text drop-shadow-lg"
        >
          Witaj w 10xDevs Astro Starter!
        </h1>
        <p class="text-xl text-blue-100/90 drop-shadow-md">
          Ten projekt został zbudowany w oparciu o nowoczesny stack technologiczny:
        </p>
      </div>

      <div class="flex flex-col gap-6 max-w-2xl mx-auto">
        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Core
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Astro v5.5.5</span>
              <span class="text-blue-100/90">- Metaframework do aplikacji webowych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">React v19</span>
              <span class="text-blue-100/90">- Biblioteka UI do komponentów interaktywnych</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">TypeScript</span>
              <span class="text-blue-100/90">- Typowanie statyczne</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Stylowanie
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Tailwind CSS v4</span
              >
              <span class="text-blue-100/90">- Utility-first CSS framework</span>
            </li>
          </ul>
        </div>

        <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-lg rounded-xl p-6 border border-white/10">
          <h2
            class="text-2xl font-semibold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-200 to-purple-200"
          >
            Statyczna analiza kodu
          </h2>
          <ul class="space-y-3">
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">ESLint v9</span>
              <span class="text-blue-100/90">- Lintowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm">Prettier</span>
              <span class="text-blue-100/90">- Formatowanie kodu</span>
            </li>
            <li class="flex items-center space-x-3">
              <span class="font-mono bg-blue-900/50 px-3 py-1.5 rounded-lg text-blue-200 shadow-sm"
                >Husky i Lint-staged</span
              >
              <span class="text-blue-100/90">- Automatyczna analiza kodu przed commitowaniem</span>
            </li>
          </ul>
        </div>
      </div>

      <p class="text-lg text-center text-blue-100/90 mt-8 leading-relaxed">
        Starter zawiera wszystko, czego potrzebujesz do rozpoczęcia tworzenia <br class="hidden sm:block" />
        <span class="font-semibold bg-gradient-to-r from-blue-200 to-purple-200 text-transparent bg-clip-text"
          >nowoczesnych aplikacji webowych!</span
        >
      </p>
    </div>

  </div>
</div>

================================================
FILE: src/components/account/AccountPage.tsx
================================================
import { useCallback, useMemo, useState } from "react";

import { useThemeMode } from "@/components/hooks/useThemeMode";
import type { AccountViewModel, ThemeMode } from "@/types";

import { DangerZoneCard } from "./DangerZoneCard";
import { LogoutButton } from "./LogoutButton";
import { ProfileCard } from "./ProfileCard";
import { ThemeToggle } from "./ThemeToggle";

type ToastTone = "success" | "error";

interface ToastState {
message: string;
tone: ToastTone;
}

interface User {
id: string;
email: string | null;
}

interface AccountPageProps {
user?: User | null;
}

const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export default function AccountPage({ user }: AccountPageProps) {
const account: AccountViewModel = useMemo(
() => ({
email: user?.email ?? "Brak e-maila",
}),
[user?.email]
);
const { mode, setMode, effectiveMode, isSystemPreferredDark } = useThemeMode();
const [toast, setToast] = useState<ToastState | null>(null);
const [isLoggingOut, setIsLoggingOut] = useState(false);
const [isDeleting, setIsDeleting] = useState(false);

const headerSubtitle = useMemo(() => "Zarządzaj ustawieniami konta, motywem i działaniami krytycznymi.", []);

const showToast = useCallback((message: string, tone: ToastTone) => setToast({ message, tone }), []);

const handleThemeChange = useCallback(
(nextMode: ThemeMode) => {
setToast(null);
try {
setMode(nextMode);
showToast(`Ustawiono motyw: ${nextMode}`, "success");
} catch {
showToast("Nie udało się zapisać motywu", "error");
}
},
[setMode, showToast]
);

const handleLogout = useCallback(async () => {
setIsLoggingOut(true);
setToast(null);
try {
const response = await fetch("/api/auth/logout", { method: "POST" });
if (!response.ok) {
const payload = (await response.json().catch(() => null)) as { error?: string } | null;
const message = payload?.error ?? "Nie udało się wylogować";
throw new Error(message);
}
window.localStorage.clear();
showToast("Wylogowano", "success");
window.location.href = "/auth/login";
} catch (error) {
showToast("Nie udało się wylogować", "error");
throw error instanceof Error ? error : new Error("logout failed");
} finally {
setIsLoggingOut(false);
}
}, [showToast]);

const handleDelete = useCallback(async () => {
setIsDeleting(true);
setToast(null);
try {
await delay(800);
showToast("Konto zostało usunięte (mock)", "success");
} catch (error) {
showToast("Nie udało się usunąć konta", "error");
throw error instanceof Error ? error : new Error("delete failed");
} finally {
setIsDeleting(false);
}
}, [showToast]);

return (

<main className="min-h-screen bg-background text-foreground">
<div className="mx-auto flex max-w-5xl flex-col gap-8 px-4 py-8">
<header className="space-y-2">
<p className="text-sm text-muted-foreground">Konto</p>
<h1 className="text-3xl font-semibold leading-tight text-foreground">Twój profil i ustawienia</h1>
<p className="max-w-3xl text-sm text-muted-foreground">{headerSubtitle}</p>
</header>

        <div className="grid gap-6 lg:grid-cols-[2fr_1fr]">
          <div className="space-y-4">
            <ProfileCard account={account} />
            <ThemeToggle
              value={mode}
              effectiveMode={effectiveMode}
              isSystemPreferredDark={isSystemPreferredDark}
              onChange={handleThemeChange}
            />
          </div>

          <div className="space-y-4">
            <LogoutButton onLogout={handleLogout} isLoggingOut={isLoggingOut} />
            <DangerZoneCard onDelete={handleDelete} isDeleting={isDeleting} />
          </div>
        </div>
      </div>
      {toast ? <InlineToast message={toast.message} tone={toast.tone} onClose={() => setToast(null)} /> : null}
    </main>

);
}

function InlineToast({ message, tone, onClose }: { message: string; tone: ToastTone; onClose: () => void }) {
const bg =
tone === "success"
? "border-emerald-200/80 bg-emerald-50 text-emerald-900"
: "border-destructive/40 bg-destructive/10 text-destructive";

return (

<div className="fixed inset-x-0 top-4 z-50 flex justify-center px-4">
<div
className={`flex items-center gap-3 rounded-lg border px-4 py-3 text-sm shadow-md backdrop-blur-sm ${bg}`}
role="status" >
<span>{message}</span>
<button
          type="button"
          className="text-muted-foreground transition hover:text-foreground"
          onClick={onClose}
          aria-label="Zamknij powiadomienie"
        >
✕
</button>
</div>
</div>
);
}

================================================
FILE: src/components/account/ConfirmationDialog.tsx
================================================
import { Button } from "@/components/ui/button";
import type { ConfirmDialogProps } from "@/types";

export function ConfirmationDialog({
open,
onOpenChange,
onConfirm,
loading,
confirmDisabled,
children,
title,
description,
confirmLabel = "Potwierdź",
}: ConfirmDialogProps) {
if (!open) {
return null;
}

return (

<div className="fixed inset-0 z-50 flex items-center justify-center bg-background/70 backdrop-blur-sm">
<div
        role="dialog"
        aria-modal="true"
        aria-labelledby="confirm-dialog-title"
        aria-describedby="confirm-dialog-description"
        className="w-full max-w-md rounded-2xl border bg-card p-6 shadow-lg"
      >
<div className="space-y-2">
<h3 id="confirm-dialog-title" className="text-xl font-semibold text-foreground">
{title}
</h3>
{description ? (
<p id="confirm-dialog-description" className="text-sm text-muted-foreground">
{description}
</p>
) : null}
{children ? <div className="mt-4 space-y-3">{children}</div> : null}
</div>

        <div className="mt-6 flex justify-end gap-3">
          <Button variant="outline" onClick={() => onOpenChange(false)} disabled={loading}>
            Anuluj
          </Button>
          <Button
            variant="destructive"
            onClick={onConfirm}
            disabled={loading || confirmDisabled}
            aria-busy={loading}
            aria-disabled={confirmDisabled}
          >
            {loading ? "Przetwarzanie..." : confirmLabel}
          </Button>
        </div>
      </div>
    </div>

);
}

================================================
FILE: src/components/account/DangerZoneCard.tsx
================================================
import { useCallback, useMemo, useState } from "react";

import { Button } from "@/components/ui/button";

import { ConfirmationDialog } from "./ConfirmationDialog";

interface DangerZoneCardProps {
onDelete: () => Promise<void>;
isDeleting: boolean;
}

const CONFIRMATION_TOKEN = "DELETE";

export function DangerZoneCard({ onDelete, isDeleting }: DangerZoneCardProps) {
const [isDialogOpen, setIsDialogOpen] = useState(false);
const [confirmationText, setConfirmationText] = useState("");

const canConfirm = useMemo(() => confirmationText.trim().toUpperCase() === CONFIRMATION_TOKEN, [confirmationText]);

const handleConfirm = useCallback(async () => {
if (!canConfirm || isDeleting) {
return;
}
try {
await onDelete();
setIsDialogOpen(false);
setConfirmationText("");
} catch {
// keep dialog open to allow another attempt
}
}, [canConfirm, isDeleting, onDelete]);

return (

<section className="rounded-2xl border border-destructive/30 bg-destructive/5 p-6 shadow-sm">
<div className="flex items-start justify-between gap-3">
<div className="space-y-1">
<p className="text-sm font-semibold text-destructive">Danger zone</p>
<h2 className="text-xl font-semibold text-foreground">Usuń konto</h2>
<p className="text-sm text-destructive/80">
Usunięcie konta jest nieodwracalne. Dane powiązane z profilem zostaną utracone (mock).
</p>
</div>
<Button variant="destructive" onClick={() => setIsDialogOpen(true)} disabled={isDeleting}>
Delete account
</Button>
</div>

      <ConfirmationDialog
        open={isDialogOpen}
        onOpenChange={setIsDialogOpen}
        onConfirm={handleConfirm}
        loading={isDeleting}
        confirmDisabled={!canConfirm}
        title="Potwierdź usunięcie konta"
        description={`Aby kontynuować, wpisz "${CONFIRMATION_TOKEN}" i potwierdź operację.`}
        confirmLabel="Usuń konto"
      >
        <label className="block space-y-2">
          <span className="text-sm font-medium text-foreground">Potwierdzenie</span>
          <input
            type="text"
            value={confirmationText}
            onChange={(event) => setConfirmationText(event.target.value)}
            className="w-full rounded-lg border border-destructive/50 bg-background px-3 py-2 text-sm text-foreground shadow-xs outline-none transition focus-visible:ring-2 focus-visible:ring-destructive/60"
            aria-invalid={!canConfirm}
            placeholder={`Wpisz ${CONFIRMATION_TOKEN}`}
          />
          <p className="text-xs text-muted-foreground">
            Wpisz dokładnie {CONFIRMATION_TOKEN}, aby aktywować przycisk potwierdzenia.
          </p>
        </label>
        <div className="flex justify-end text-xs text-muted-foreground">
          {isDeleting ? "Usuwanie..." : canConfirm ? "Gotowe do usunięcia" : "Wymagane potwierdzenie"}
        </div>
      </ConfirmationDialog>
    </section>

);
}

================================================
FILE: src/components/account/LogoutButton.tsx
================================================
import { Button } from "@/components/ui/button";

interface LogoutButtonProps {
onLogout: () => Promise<void>;
isLoggingOut: boolean;
}

export function LogoutButton({ onLogout, isLoggingOut }: LogoutButtonProps) {
return (

<section className="rounded-2xl border bg-card p-6 shadow-sm" aria-labelledby="logout-title">
<div className="flex items-start justify-between gap-3">
<div className="space-y-1">
<p className="text-sm text-muted-foreground">Sesja</p>
<h2 id="logout-title" className="text-xl font-semibold text-foreground">
Wyloguj się
</h2>
<p className="text-sm text-muted-foreground">
Wylogowanie wyczyści lokalne dane sesji i wróci do ekranu głównego.
</p>
</div>
<Button variant="outline" onClick={onLogout} disabled={isLoggingOut} aria-busy={isLoggingOut}>
{isLoggingOut ? "Wylogowywanie..." : "Wyloguj"}
</Button>
</div>
</section>
);
}

================================================
FILE: src/components/account/ProfileCard.tsx
================================================
import type { AccountViewModel } from "@/types";

interface ProfileCardProps {
account: AccountViewModel;
}

export function ProfileCard({ account }: ProfileCardProps) {
return (

<section className="rounded-2xl border bg-card p-6 shadow-sm" aria-labelledby="account-profile-title">
<div className="flex items-start justify-between gap-3">
<div className="space-y-1">
<p className="text-sm text-muted-foreground">Profil</p>
<h2 id="account-profile-title" className="text-xl font-semibold text-foreground">
Dane konta
</h2>
<p className="text-sm text-muted-foreground">Podstawowe informacje o Twoim profilu.</p>
</div>
</div>

      <dl className="mt-6">
        <div className="rounded-xl border bg-background px-4 py-3">
          <dt className="text-sm text-muted-foreground">E-mail</dt>
          <dd className="text-base font-medium text-foreground">{account.email}</dd>
        </div>
      </dl>
    </section>

);
}

================================================
FILE: src/components/account/ThemeToggle.tsx
================================================
import type { ThemeMode } from "@/types";

interface ThemeToggleProps {
value: ThemeMode;
effectiveMode: ThemeMode;
isSystemPreferredDark: boolean;
onChange: (mode: ThemeMode) => void;
}

export function ThemeToggle({ value, effectiveMode, isSystemPreferredDark, onChange }: ThemeToggleProps) {
return (

<section className="rounded-2xl border bg-card p-6 shadow-sm" aria-labelledby="theme-toggle-title">
<div className="space-y-2">
<p className="text-sm text-muted-foreground">Wygląd</p>
<h2 id="theme-toggle-title" className="text-xl font-semibold text-foreground">
Motyw aplikacji
</h2>
<p className="text-sm text-muted-foreground">
Wybierz preferowany motyw. Ustawienie system automatycznie dostosuje się do motywu systemu operacyjnego.
</p>
</div>

      <div className="mt-4 grid gap-4 md:grid-cols-2">
        <label className="space-y-2">
          <span className="text-sm font-medium text-foreground">Tryb</span>
          <select
            value={value}
            onChange={(event) => onChange(event.target.value as ThemeMode)}
            className="w-full rounded-lg border border-input bg-background px-3 py-2 text-sm text-foreground shadow-xs outline-none transition focus-visible:ring-2 focus-visible:ring-ring"
          >
            <option value="light">Jasny</option>
            <option value="dark">Ciemny</option>
            <option value="system">System</option>
          </select>
          <p className="text-xs text-muted-foreground">
            Aktualnie aktywny motyw: <strong className="font-semibold text-foreground">{effectiveMode}</strong>
          </p>
        </label>

        <div className="space-y-2 rounded-xl border bg-background px-4 py-3 text-sm text-muted-foreground">
          <p className="font-medium text-foreground">Stan systemu</p>
          <p className="text-muted-foreground">System preferuje: {isSystemPreferredDark ? "ciemny" : "jasny"} tryb.</p>
          <p className="text-muted-foreground">
            Zmiana preferencji systemu automatycznie przełączy motyw, jeśli wybrano opcję „System”.
          </p>
        </div>
      </div>
    </section>

);
}

================================================
FILE: src/components/auth/AuthCard.tsx
================================================
import { type ReactNode } from "react";

import { cn } from "@/lib/utils";

interface AuthCardProps {
title: string;
description?: string;
children: ReactNode;
footer?: ReactNode;
className?: string;
}

export function AuthCard({ title, description, children, footer, className }: AuthCardProps) {
return (

<div
className={cn(
"rounded-3xl border border-border bg-card/90 p-6 shadow-lg shadow-black/5 dark:shadow-black/40 min-w-xl",
className
)} >
<div className="space-y-1 pb-4">
<h2 className="text-2xl font-semibold text-foreground">{title}</h2>
{description ? <p className="text-sm text-muted-foreground">{description}</p> : null}
</div>
<div className="space-y-6">{children}</div>
{footer ? <div className="mt-6 border-t border-border pt-4 text-sm text-muted-foreground">{footer}</div> : null}
</div>
);
}

================================================
FILE: src/components/auth/FormField.tsx
================================================
"use client";

import { cn } from "@/lib/utils";
import type { ReactNode } from "react";

interface FormFieldProps {
label: string;
children: ReactNode;
helper?: string;
error?: string;
htmlFor?: string;
className?: string;
}

export function FormField({ label, children, helper, error, htmlFor, className }: FormFieldProps) {
return (

<div className={cn("flex flex-col gap-1 text-sm text-foreground bg-transparent", className)}>
<label htmlFor={htmlFor} className="font-medium">
{label}
</label>
{children}
{helper ? <p className="text-xs text-muted-foreground">{helper}</p> : null}
{error ? <p className="text-xs text-destructive">{error}</p> : null}
</div>
);
}

================================================
FILE: src/components/auth/LoginForm.tsx
================================================
import { useCallback, useId, useMemo, useState, type FormEvent } from "react";
import { z } from "zod";

import { Button } from "../ui/button";
import { AuthCard } from "./AuthCard";
import { FormField } from "./FormField";
import { loginSchema } from "@/lib/validation/authSchemas";

type LoginFormValues = z.infer<typeof loginSchema>;

interface LoginFormStatus {
type: "success" | "error";
message: string;
}

interface LoginFormProps {
onSubmit?: (values: LoginFormValues) => Promise<void>;
}

export function LoginForm({ onSubmit }: LoginFormProps) {
const [formValues, setFormValues] = useState<LoginFormValues>({ email: "", password: "" });
const [errors, setErrors] = useState<Partial<Record<keyof LoginFormValues, string>>>({});
const [status, setStatus] = useState<LoginFormStatus | null>(null);
const [isSubmitting, setIsSubmitting] = useState(false);
const baseId = useId();

const defaultSubmit = useCallback(async (values: LoginFormValues) => {
const response = await fetch("/api/auth/login", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(values),
});

    if (!response.ok) {
      const payload = await response.json().catch(() => ({}));
      const fallbackMessage = "Nie udało się zalogować. Spróbuj ponownie.";
      const message = typeof payload?.error === "string" ? payload.error : fallbackMessage;
      throw new Error(message);
    }

    window.location.href = "/";

}, []);

const handleChange = useCallback((field: keyof LoginFormValues, value: string) => {
setFormValues((prev) => ({ ...prev, [field]: value }));
setErrors((prev) => ({ ...prev, [field]: undefined }));
setStatus(null);
}, []);

const handleSubmit = useCallback(
async (event: FormEvent<HTMLFormElement>) => {
event.preventDefault();
setStatus(null);
const parsed = loginSchema.safeParse(formValues);
if (!parsed.success) {
const fieldErrors = Object.entries(parsed.error.formErrors.fieldErrors).reduce(
(acc, [key, value]) => {
if (value && value.length) {
acc[key as keyof LoginFormValues] = value[0];
}
return acc;
},
{} as Partial<Record<keyof LoginFormValues, string>>
);
setErrors(fieldErrors);
return;
}

      setErrors({});
      setIsSubmitting(true);
      try {
        await (onSubmit ?? defaultSubmit)(parsed.data);
        setStatus({
          type: "success",
          message: "Zalogowano pomyślnie. Przekierowuję do Twoich fiszek.",
        });
      } catch (error) {
        setStatus({
          type: "error",
          message: error instanceof Error ? error.message : "Nie udało się zalogować.",
        });
      } finally {
        setIsSubmitting(false);
      }
    },
    [defaultSubmit, formValues, onSubmit]

);

const statusClasses = useMemo(() => {
if (!status) return "";
return status.type === "success"
? "rounded-lg border border-emerald-200 bg-emerald-50 px-3 py-2 text-sm text-emerald-900"
: "rounded-lg border border-destructive/50 bg-destructive/10 px-3 py-2 text-sm text-destructive";
}, [status]);

return (
<AuthCard
title="Logowanie"
description="Użyj emaila i hasła, aby uzyskać dostęp do panelu."
footer={

<div className="flex flex-wrap items-center justify-between gap-2 text-xs text-muted-foreground">
<span>Nie masz konta?</span>
<a className="underline" href="/auth/register">
Zarejestruj się
</a>
<a className="underline" href="/auth/reset">
Nie pamiętasz hasła?
</a>
</div>
} >
<div className="space-y-4">
{status ? (
<div className={statusClasses} role="status" aria-live="polite">
{status.message}
</div>
) : null}

        <form className="space-y-4" onSubmit={handleSubmit} noValidate>
          <FormField label="Email" htmlFor={`${baseId}-email`} error={errors.email}>
            <input
              id={`${baseId}-email`}
              name="email"
              type="email"
              autoComplete="email"
              value={formValues.email}
              onChange={(event) => handleChange("email", event.target.value)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="you@example.com"
              required
            />
          </FormField>
          <FormField label="Hasło" htmlFor={`${baseId}-password`} error={errors.password} helper="Minimum 8 znaków.">
            <input
              id={`${baseId}-password`}
              name="password"
              type="password"
              autoComplete="current-password"
              value={formValues.password}
              onChange={(event) => handleChange("password", event.target.value)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="••••••••••••"
              required
            />
          </FormField>
          <div className="flex justify-end">
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? "Łączenie..." : "Zaloguj się"}
            </Button>
          </div>
        </form>
      </div>
    </AuthCard>

);
}

================================================
FILE: src/components/auth/PasswordRequirementList.tsx
================================================
"use client";

import { cn } from "@/lib/utils";

import { passwordRequirements } from "@/lib/validation/authSchemas";

export function PasswordRequirementList({ value }: { value: string }) {
return (

<ul className="grid gap-1 text-xs sm:text-sm">
{passwordRequirements.map((requirement) => {
const met = requirement.test(value);
return (
<li key={requirement.id} className="flex items-center gap-2">
<span
className={cn(
"flex h-4 w-4 items-center justify-center rounded-full border text-[0.6rem] font-semibold leading-none transition",
met ? "border-emerald-400 bg-emerald-50 text-emerald-700" : "border-border text-muted-foreground"
)}
aria-hidden="true" >
{met ? "✓" : ""}
</span>
<span className={cn("leading-snug", met ? "text-foreground" : "text-muted-foreground")}>
{requirement.label}
</span>
</li>
);
})}
</ul>
);
}

================================================
FILE: src/components/auth/RegisterForm.tsx
================================================
"use client";

import { useCallback, useId, useMemo, useState, type FormEvent } from "react";
import { z } from "zod";

import { Button } from "../ui/button";
import { AuthCard } from "./AuthCard";
import { FormField } from "./FormField";
import { PasswordRequirementList } from "./PasswordRequirementList";
import { registerSchema } from "@/lib/validation/authSchemas";

type RegisterFormValues = z.infer<typeof registerSchema>;

interface FormStatus {
type: "success" | "error";
message: string;
}

interface RegisterFormProps {
onSubmit?: (values: RegisterFormValues) => Promise<{ message?: string } | undefined>;
}

const DEFAULT_SUCCESS_MESSAGE = "Konto utworzone. Sprawdź skrzynkę i potwierdź email, aby się zalogować.";

export function RegisterForm({ onSubmit }: RegisterFormProps) {
const [formValues, setFormValues] = useState<RegisterFormValues>({
email: "",
password: "",
confirmPassword: "",
});
const [errors, setErrors] = useState<Partial<Record<keyof RegisterFormValues, string>>>({});
const [status, setStatus] = useState<FormStatus | null>(null);
const [isSubmitting, setIsSubmitting] = useState(false);
const baseId = useId();

const defaultSubmit = useCallback(async (values: RegisterFormValues): Promise<{ message?: string }> => {
const response = await fetch("/api/auth/register", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(values),
});

    const payload = await response.json().catch(() => ({}));

    if (!response.ok) {
      const fallbackMessage = "Nie udało się zarejestrować. Spróbuj ponownie.";
      const message = typeof payload?.error === "string" ? payload.error : fallbackMessage;
      throw new Error(message);
    }

    const message =
      typeof payload === "object" && payload !== null && "message" in payload && typeof payload.message === "string"
        ? payload.message
        : DEFAULT_SUCCESS_MESSAGE;

    return { message };

}, []);

const handleChange = useCallback((field: keyof RegisterFormValues, value: string) => {
setFormValues((prev) => ({ ...prev, [field]: value }));
setErrors((prev) => ({ ...prev, [field]: undefined }));
setStatus(null);
}, []);

const handleSubmit = useCallback(
async (event: FormEvent<HTMLFormElement>) => {
event.preventDefault();
setStatus(null);
const parsed = registerSchema.safeParse(formValues);
if (!parsed.success) {
const fieldErrors = Object.entries(parsed.error.formErrors.fieldErrors).reduce(
(acc, [key, value]) => {
if (value && value.length) {
acc[key as keyof RegisterFormValues] = value[0];
}
return acc;
},
{} as Partial<Record<keyof RegisterFormValues, string>>
);
setErrors(fieldErrors);
return;
}

      setErrors({});
      setIsSubmitting(true);
      try {
        const payload = await (onSubmit ?? defaultSubmit)(parsed.data);
        const successMessage =
          typeof payload === "object" &&
          payload !== null &&
          "message" in payload &&
          typeof (payload as { message?: unknown }).message === "string"
            ? (payload as { message: string }).message
            : DEFAULT_SUCCESS_MESSAGE;
        setStatus({
          type: "success",
          message: successMessage,
        });
      } catch (error) {
        setStatus({
          type: "error",
          message: error instanceof Error ? error.message : "Nie udało się zarejestrować.",
        });
      } finally {
        setIsSubmitting(false);
      }
    },
    [defaultSubmit, formValues, onSubmit]

);

const statusClasses = useMemo(() => {
if (!status) return "";
return status.type === "success"
? "rounded-lg border border-emerald-200 bg-emerald-50 px-3 py-2 text-sm text-emerald-900"
: "rounded-lg border border-destructive/50 bg-destructive/10 px-3 py-2 text-sm text-destructive";
}, [status]);

return (
<AuthCard
title="Rejestracja"
description="Dodaj email oraz silne hasło, aby utworzyć konto."
footer={

<div className="flex flex-wrap items-center justify-between gap-2 text-xs text-muted-foreground">
<span>Masz już konto?</span>
<a className="underline" href="/auth/login">
Zaloguj się
</a>
<a className="underline" href="/auth/reset">
Zapomniałeś hasła?
</a>
</div>
} >
<div className="space-y-4">
{status ? (
<div className={statusClasses} role="status" aria-live="polite">
{status.message}
</div>
) : null}

        <form className="space-y-4" onSubmit={handleSubmit} noValidate>
          <FormField label="Email" htmlFor={`${baseId}-email`} error={errors.email}>
            <input
              id={`${baseId}-email`}
              name="email"
              type="email"
              autoComplete="email"
              value={formValues.email}
              onChange={(event) => handleChange("email", event.target.value)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="you@example.com"
              required
            />
          </FormField>
          <FormField label="Hasło" htmlFor={`${baseId}-password`} error={errors.password}>
            <input
              id={`${baseId}-password`}
              name="password"
              type="password"
              autoComplete="new-password"
              value={formValues.password}
              onChange={(event) => handleChange("password", event.target.value)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="••••••••••"
              required
            />
            <p className="mt-3 text-xs text-muted-foreground">Hasło musi spełniać poniższe kryteria:</p>
            <PasswordRequirementList value={formValues.password} />
          </FormField>
          <FormField
            label="Potwierdź hasło"
            htmlFor={`${baseId}-confirm`}
            error={errors.confirmPassword}
            helper="Wprowadź hasło raz jeszcze, by potwierdzić."
          >
            <input
              id={`${baseId}-confirm`}
              name="confirmPassword"
              type="password"
              autoComplete="new-password"
              value={formValues.confirmPassword}
              onChange={(event) => handleChange("confirmPassword", event.target.value)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="••••••••••••••"
              required
            />
          </FormField>
          <div className="flex justify-end">
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? "Rejestrowanie..." : "Zarejestruj się"}
            </Button>
          </div>
        </form>
      </div>
    </AuthCard>

);
}

================================================
FILE: src/components/auth/ResetConfirmForm.tsx
================================================
"use client";

import { useCallback, useId, useMemo, useState } from "react";
import { z } from "zod";

import { Button } from "../ui/button";
import { AuthCard } from "./AuthCard";
import { FormField } from "./FormField";
import { PasswordRequirementList } from "./PasswordRequirementList";
import { resetConfirmSchema } from "@/lib/validation/authSchemas";

type ResetConfirmFormValues = z.infer<typeof resetConfirmSchema>;

interface ConfirmStatus {
type: "success" | "error";
message: string;
}

interface ResetConfirmFormProps {
token?: string | null;
onSubmit?: (values: ResetConfirmFormValues & { token?: string | null }) => Promise<void>;
}

export function ResetConfirmForm({ token, onSubmit }: ResetConfirmFormProps) {
const [formValues, setFormValues] = useState<ResetConfirmFormValues>({
password: "",
confirmPassword: "",
});
const [errors, setErrors] = useState<Partial<Record<keyof ResetConfirmFormValues, string>>>({});
const [status, setStatus] = useState<ConfirmStatus | null>(null);
const [isSubmitting, setIsSubmitting] = useState(false);
const baseId = useId();
const isTokenMissing = !token;

const defaultSubmit = useCallback(async (values: ResetConfirmFormValues & { token?: string | null }) => {
const response = await fetch("/api/auth/reset/confirm", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(values),
});

    const payload = await response.json().catch(() => null);
    if (!response.ok) {
      const fallbackMessage = "Nie udało się zresetować hasła. Spróbuj ponownie.";
      const message = typeof payload?.error === "string" ? payload.error : fallbackMessage;
      throw new Error(message);
    }

}, []);

const handleChange = useCallback((field: keyof ResetConfirmFormValues, value: string) => {
setFormValues((prev) => ({ ...prev, [field]: value }));
setErrors((prev) => ({ ...prev, [field]: undefined }));
setStatus(null);
}, []);

const handleSubmit = useCallback(
async (event: React.FormEvent<HTMLFormElement>) => {
event.preventDefault();
setStatus(null);
if (isTokenMissing) {
setStatus({
type: "error",
message: "Brak tokenu resetu. Użyj linku z wiadomości email lub poproś o nowy.",
});
return;
}

      const parsed = resetConfirmSchema.safeParse(formValues);
      if (!parsed.success) {
        const fieldErrors = Object.entries(parsed.error.formErrors.fieldErrors).reduce(
          (acc, [key, value]) => {
            if (value && value.length) {
              acc[key as keyof ResetConfirmFormValues] = value[0];
            }
            return acc;
          },
          {} as Partial<Record<keyof ResetConfirmFormValues, string>>
        );
        setErrors(fieldErrors);
        return;
      }

      setErrors({});
      setIsSubmitting(true);
      try {
        await (onSubmit ?? defaultSubmit)({ ...parsed.data, token });
        setStatus({
          type: "success",
          message: "Hasło zostało zaktualizowane. Przekierowuję do logowania.",
        });
        setTimeout(() => {
          window.location.href = "/auth/login";
        }, 1200);
      } catch (error) {
        setStatus({
          type: "error",
          message: error instanceof Error ? error.message : "Nie udało się zresetować hasła.",
        });
      } finally {
        setIsSubmitting(false);
      }
    },
    [defaultSubmit, formValues, isTokenMissing, onSubmit, token]

);

const statusClasses = useMemo(() => {
if (!status) return "";
return status.type === "success"
? "rounded-lg border border-emerald-200 bg-emerald-50 px-3 py-2 text-sm text-emerald-900"
: "rounded-lg border border-destructive/50 bg-destructive/10 px-3 py-2 text-sm text-destructive";
}, [status]);

return (
<AuthCard
      title="Ustaw nowe hasło"
      description="Podaj nowe, silne hasło. Token z linku resetującego został automatycznie rozpoznany."
    >

<div className="space-y-4">
{!token ? (
<div className="rounded-lg border border-destructive/30 bg-destructive/5 px-3 py-2 text-xs text-destructive">
Nie znaleziono tokenu resetu. Użyj linku z wiadomości email, aby ustawić nowe hasło.
</div>
) : null}

        {status ? (
          <div className={statusClasses} role="status" aria-live="polite">
            {status.message}
          </div>
        ) : null}

        <form className="space-y-4" onSubmit={handleSubmit} noValidate>
          <FormField label="Nowe hasło" htmlFor={`${baseId}-password`} error={errors.password}>
            <input
              id={`${baseId}-password`}
              name="password"
              type="password"
              autoComplete="new-password"
              value={formValues.password}
              onChange={(event) => handleChange("password", event.target.value)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="••••••••••••••"
              required
            />
            <p className="mt-3 text-xs text-muted-foreground">Hasło musi spełniać podane kryteria.</p>
            <PasswordRequirementList value={formValues.password} />
          </FormField>

          <FormField
            label="Powtórz nowe hasło"
            htmlFor={`${baseId}-confirm`}
            error={errors.confirmPassword}
            helper="Musi dokładnie zgadzać się z nowym hasłem."
          >
            <input
              id={`${baseId}-confirm`}
              name="confirmPassword"
              type="password"
              autoComplete="new-password"
              value={formValues.confirmPassword}
              onChange={(event) => handleChange("confirmPassword", event.target.value)}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="••••••••••••••"
              required
            />
          </FormField>
          <div className="flex justify-end">
            <Button type="submit" disabled={isSubmitting || isTokenMissing}>
              {isSubmitting ? "Aktualizuję..." : "Zapisz nowe hasło"}
            </Button>
          </div>
        </form>
      </div>
    </AuthCard>

);
}

================================================
FILE: src/components/auth/ResetRequestForm.tsx
================================================
"use client";

import { useCallback, useId, useMemo, useState } from "react";
import { z } from "zod";

import { Button } from "../ui/button";
import { AuthCard } from "./AuthCard";
import { FormField } from "./FormField";
import { resetRequestSchema } from "@/lib/validation/authSchemas";

type ResetRequestFormValues = z.infer<typeof resetRequestSchema>;

interface ResetRequestStatus {
type: "success" | "error";
message: string;
}

interface ResetRequestFormProps {
onSubmit?: (values: ResetRequestFormValues) => Promise<void>;
}

export function ResetRequestForm({ onSubmit }: ResetRequestFormProps) {
const [formValues, setFormValues] = useState<ResetRequestFormValues>({ email: "" });
const [errors, setErrors] = useState<Partial<Record<keyof ResetRequestFormValues, string>>>({});
const [status, setStatus] = useState<ResetRequestStatus | null>(null);
const [isSubmitting, setIsSubmitting] = useState(false);
const emailId = useId();

const defaultSubmit = useCallback(async (values: ResetRequestFormValues) => {
const response = await fetch("/api/auth/reset", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(values),
});

    if (!response.ok) {
      const payload = await response.json().catch(() => null);
      const fallbackMessage = "Nie udało się wysłać instrukcji. Spróbuj ponownie.";
      const message = typeof payload?.error === "string" ? payload.error : fallbackMessage;
      throw new Error(message);
    }

}, []);

const handleSubmit = useCallback(
async (event: React.FormEvent<HTMLFormElement>) => {
event.preventDefault();
setStatus(null);
const parsed = resetRequestSchema.safeParse(formValues);
if (!parsed.success) {
const fieldErrors = Object.entries(parsed.error.formErrors.fieldErrors).reduce(
(acc, [key, value]) => {
if (value && value.length) {
acc[key as keyof ResetRequestFormValues] = value[0];
}
return acc;
},
{} as Partial<Record<keyof ResetRequestFormValues, string>>
);
setErrors(fieldErrors);
return;
}

      setErrors({});
      setIsSubmitting(true);
      try {
        await (onSubmit ?? defaultSubmit)(parsed.data);
        setStatus({
          type: "success",
          message: "Jeśli konto istnieje, wkrótce otrzymasz link do resetu hasła.",
        });
      } catch (error) {
        setStatus({
          type: "error",
          message: error instanceof Error ? error.message : "Nie udało się wysłać instrukcji.",
        });
      } finally {
        setIsSubmitting(false);
      }
    },
    [defaultSubmit, formValues, onSubmit]

);

const statusClasses = useMemo(() => {
if (!status) return "";
return status.type === "success"
? "rounded-lg border border-emerald-200 bg-emerald-50 px-3 py-2 text-sm text-emerald-900"
: "rounded-lg border border-destructive/50 bg-destructive/10 px-3 py-2 text-sm text-destructive";
}, [status]);

return (
<AuthCard
title="Reset hasła"
description="Podaj adres email, a wyślemy instrukcje resetu."
footer={

<div className="flex flex-wrap items-center justify-between gap-2 text-xs text-muted-foreground">
<span>Możesz też zalogować się ponownie</span>
<a className="underline" href="/auth/login">
Powrót do logowania
</a>
<a className="underline" href="/auth/register">
Zarejestruj się
</a>
</div>
} >
<div className="space-y-4">
{status ? (
<div className={statusClasses} role="status" aria-live="polite">
{status.message}
</div>
) : null}

        <form className="space-y-4" onSubmit={handleSubmit} noValidate>
          <FormField label="Email" htmlFor={`${emailId}-email`} error={errors.email}>
            <input
              id={`${emailId}-email`}
              name="email"
              type="email"
              autoComplete="email"
              value={formValues.email}
              onChange={(event) => {
                setFormValues({ email: event.target.value });
                setErrors({});
                setStatus(null);
              }}
              className="w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:border-ring focus-visible:ring-2 focus-visible:ring-ring"
              placeholder="you@example.com"
              required
            />
          </FormField>
          <div className="text-xs text-muted-foreground">
            Nie ujawniamy, czy konto istnieje. Informację o kolejnym kroku otrzymasz w każdym przypadku.
          </div>
          <div className="flex justify-end">
            <Button type="submit" disabled={isSubmitting}>
              {isSubmitting ? "Wysyłanie..." : "Wyślij instrukcje"}
            </Button>
          </div>
        </form>
      </div>
    </AuthCard>

);
}

================================================
FILE: src/components/flashcards/MyFlashcardsView.tsx
================================================
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import { cn } from "@/lib/utils";

import { useFlashcardsList } from "../hooks/useFlashcardsList";
import { Button } from "../ui/button";
import type { SourceEnum } from "../../types";
import type { FlashcardViewModel, SortOption } from "../../lib/view-models/flashcards";

const sourceFilters: { value?: SourceEnum; label: string }[] = [
{ value: undefined, label: "Wszystkie źródła" },
{ value: "ai_generated", label: "AI wygenerowane" },
{ value: "ai_edited", label: "AI edytowane" },
{ value: "manual", label: "Ręczne" },
];

const sortOptions: { value: SortOption; label: string }[] = [
{ value: "created_at desc", label: "Najnowsze" },
{ value: "created_at asc", label: "Najstarsze" },
];

function EditIcon() {
return (
<svg aria-hidden="true" className="size-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
<path d="M12 20h9" />
<path d="M16.5 3.5a2.121 2.121 0 1 1 3 3L7 19l-4 1 1-4Z" />
</svg>
);
}

function TrashIcon() {
return (
<svg aria-hidden="true" className="size-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
<path d="M3 6h18" />
<path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6" />
<path d="M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />
</svg>
);
}

export default function MyFlashcardsView() {
const [isAddOpen, setIsAddOpen] = useState(false);
const [editing, setEditing] = useState<FlashcardViewModel | null>(null);
const [deleting, setDeleting] = useState<FlashcardViewModel | null>(null);
const {
items,
isLoading,
hasMore,
error,
source,
sort,
total,
loadMore,
loadInitial,
applySource,
applySort,
createOne,
updateRemote,
deleteRemote,
} = useFlashcardsList();

const { addToast, ToastHost } = useToastHost();

const sentinelRef = useInfiniteScroll({ canLoad: hasMore && !isLoading, onLoadMore: loadMore });

const handleDelete = useCallback(async (item: FlashcardViewModel) => {
setDeleting(item);
}, []);

const handleGenerate = useCallback(() => {
window.location.href = "/generate";
}, []);

const handleCreate = useCallback(() => {
setIsAddOpen(true);
}, []);

const handleEdit = useCallback((item: FlashcardViewModel) => {
setEditing(item);
}, []);

const emptyState = !isLoading && items.length === 0;

return (

<div className="min-h-screen bg-background text-foreground">
<div className="mx-auto flex max-w-6xl flex-col gap-6 px-4 py-6">
<TopBar onGenerate={handleGenerate} onCreate={handleCreate} />
<FiltersBar
source={source}
sort={sort}
onSourceChange={(value) => applySource(value)}
onSortChange={(value) => applySort(value)}
/>

        {error ? <InlineAlert message={error} onRetry={() => loadInitial()} /> : null}

        {emptyState ? (
          <EmptyState onCreate={handleCreate} onGenerate={handleGenerate} />
        ) : (
          <InfiniteFlashcardGrid
            items={items}
            isLoading={isLoading}
            hasMore={hasMore}
            onEdit={handleEdit}
            onDelete={handleDelete}
            sentinelRef={sentinelRef}
            total={total}
            error={error}
            onRetry={loadMore}
          />
        )}

        <ProgressIndicator total={total} visible={!emptyState} isLoading={isLoading} />

        <AddFlashcardDialog
          isOpen={isAddOpen}
          onClose={() => setIsAddOpen(false)}
          onCreated={async (payload) => {
            try {
              await createOne({ payload });
              addToast({ type: "success", message: "Fiszka utworzona" });
              setIsAddOpen(false);
            } catch (err) {
              addToast({ type: "error", message: err instanceof Error ? err.message : "Nie udało się utworzyć" });
            }
          }}
        />
        <EditFlashcardDialog
          item={editing}
          isOpen={Boolean(editing)}
          onClose={() => setEditing(null)}
          onUpdated={async (payload) => {
            if (!editing) return;
            try {
              const updated = await updateRemote({ id: editing.id, payload });
              setEditing(updated);
              addToast({ type: "success", message: "Zaktualizowano fiszkę" });
              setEditing(null);
            } catch (err) {
              addToast({ type: "error", message: err instanceof Error ? err.message : "Nie udało się zapisać" });
            }
          }}
        />
        <DeleteFlashcardDialog
          item={deleting}
          isOpen={Boolean(deleting)}
          onClose={() => setDeleting(null)}
          onDeleted={async () => {
            if (!deleting) return;
            try {
              await deleteRemote({ id: deleting.id });
              addToast({ type: "success", message: "Usunięto fiszkę" });
              setDeleting(null);
            } catch (err) {
              addToast({ type: "error", message: err instanceof Error ? err.message : "Nie udało się usunąć" });
            }
          }}
        />
        <ToastHost />
      </div>
    </div>

);
}

function TopBar({ onGenerate, onCreate }: { onGenerate: () => void; onCreate: () => void }) {
return (

<header className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
<div>
<p className="text-sm text-muted-foreground">Moje fiszki</p>
<h1 className="text-2xl font-semibold leading-tight">Zapisane fiszki</h1>
</div>
<div className="flex flex-wrap gap-2">
<Button variant="outline" onClick={onGenerate}>
Generuj
</Button>
<Button onClick={onCreate}>Utwórz</Button>
</div>
</header>
);
}

function FiltersBar({
source,
sort,
onSourceChange,
onSortChange,
}: {
source?: SourceEnum;
sort: SortOption;
onSourceChange: (value?: SourceEnum) => void;
onSortChange: (value: SortOption) => void;
}) {
return (

<div className="flex flex-col gap-3 rounded-xl border bg-card px-4 py-3 shadow-xs sm:flex-row sm:items-center sm:justify-between">
<div className="flex flex-wrap gap-2">
{sourceFilters.map((option) => (
<FilterPill
key={option.label}
active={source === option.value || (!source && option.value === undefined)}
onClick={() => onSourceChange(option.value)} >
{option.label}
</FilterPill>
))}
</div>
<div className="flex items-center gap-2 text-sm">
<span className="text-muted-foreground">Sortuj:</span>
<select
className="rounded-md border border-input bg-background px-2 py-1 text-sm outline-none focus-visible:ring-2 focus-visible:ring-ring"
value={sort}
onChange={(event) => onSortChange(event.target.value as SortOption)} >
{sortOptions.map((option) => (
<option key={option.value} value={option.value}>
{option.label}
</option>
))}
</select>
</div>
</div>
);
}

function InfiniteFlashcardGrid({
items,
isLoading,
hasMore,
onEdit,
onDelete,
sentinelRef,
total,
error,
onRetry,
}: {
items: FlashcardViewModel[];
isLoading: boolean;
hasMore: boolean;
onEdit: (item: FlashcardViewModel) => void;
onDelete: (item: FlashcardViewModel) => void;
sentinelRef: React.RefObject<HTMLDivElement | null>;
total: number;
error: string | null;
onRetry: () => void;
}) {
return (

<section className="flex flex-col gap-4">
<div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
{items.map((item) => (
<FlashcardCard key={item.id} item={item} onEdit={onEdit} onDelete={onDelete} />
))}
{isLoading && Array.from({ length: 6 }).map((\_, index) => <FlashcardSkeleton key={`skeleton-${index}`} />)}
</div>

      <div ref={sentinelRef} className="h-8 w-full" aria-hidden />

      {!isLoading && hasMore ? (
        <div className="text-center text-sm text-muted-foreground">Wczytywanie kolejnych fiszek...</div>
      ) : null}

      {!hasMore && total > 0 ? (
        <div className="text-center text-sm text-muted-foreground">Wszystkie fiszki są widoczne.</div>
      ) : null}

      {error ? <InlineAlert message={error} onRetry={onRetry} /> : null}
    </section>

);
}

function FlashcardCard({
item,
onEdit,
onDelete,
}: {
item: FlashcardViewModel;
onEdit: (item: FlashcardViewModel) => void;
onDelete: (item: FlashcardViewModel) => void;
}) {
const sourceLabel = useMemo(() => {
switch (item.source) {
case "ai_generated":
return "AI";
case "ai_edited":
return "AI (edyt.)";
default:
return "Ręczne";
}
}, [item.source]);

return (

<article className="group flex h-full flex-col justify-between rounded-xl border bg-card p-4 shadow-sm transition hover:border-ring hover:bg-accent hover:shadow-md">
<div className="space-y-2">
<div className="flex items-start justify-between gap-3">
<p className="line-clamp-3 text-base font-medium leading-tight text-foreground">{item.front}</p>
<span className="shrink-0 rounded-full bg-muted px-2 py-1 text-xs font-medium text-muted-foreground">
{sourceLabel}
</span>
</div>
<p className="text-sm text-muted-foreground">{item.createdLabel}</p>
</div>
<div className="mt-3 flex items-center justify-end gap-2 text-sm text-muted-foreground">
<Button size="icon" variant="ghost" aria-label="Edytuj fiszkę" onClick={() => onEdit(item)}>
<EditIcon />
</Button>
<Button
size="icon"
variant="ghost"
className="text-destructive"
aria-label="Usuń fiszkę"
onClick={() => onDelete(item)} >
<TrashIcon />
</Button>
</div>
</article>
);
}

function FlashcardSkeleton() {
return (

<div className="animate-pulse rounded-xl border bg-muted/30 p-4">
<div className="mb-3 h-4 w-10/12 rounded bg-muted" />
<div className="mb-2 h-4 w-9/12 rounded bg-muted" />
<div className="h-4 w-6/12 rounded bg-muted" />
</div>
);
}

interface FlashcardFormState {
front: string;
back: string;
}

const defaultFormState: FlashcardFormState = {
front: "",
back: "",
};

function validateForm(state: FlashcardFormState) {
const errors: Partial<Record<keyof FlashcardFormState, string>> = {};
if (!state.front.trim() || state.front.trim().length < 1 || state.front.trim().length > 200) {
errors.front = "Front musi mieć 1-200 znaków";
}
if (!state.back.trim() || state.back.trim().length < 1 || state.back.trim().length > 500) {
errors.back = "Back musi mieć 1-500 znaków";
}
return errors;
}

function AddFlashcardDialog({
isOpen,
onClose,
onCreated,
}: {
isOpen: boolean;
onClose: () => void;
onCreated: (payload: {
front: string;
back: string;
source: SourceEnum;
generationId: string | null;
}) => Promise<void>;
}) {
const [form, setForm] = useState<FlashcardFormState>(defaultFormState);
const [errors, setErrors] = useState<Partial<Record<keyof FlashcardFormState, string>>>({});
const [submitting, setSubmitting] = useState(false);

useEffect(() => {
if (isOpen) {
setForm(defaultFormState);
setErrors({});
}
}, [isOpen]);

const handleSubmit = async (event: React.FormEvent) => {
event.preventDefault();
const validation = validateForm(form);
setErrors(validation);
if (Object.keys(validation).length > 0) return;
setSubmitting(true);
try {
await onCreated({
front: form.front.trim(),
back: form.back.trim(),
source: "manual",
generationId: null,
});
} catch (err) {
setErrors({ front: err instanceof Error ? err.message : "Nie udało się utworzyć" });
} finally {
setSubmitting(false);
}
};

if (!isOpen) return null;

return (

<Dialog onClose={onClose} title="Utwórz fiszkę">
<form className="space-y-4" onSubmit={handleSubmit}>
<Field
label="Front"
error={errors.front}
input={
<textarea
value={form.front}
onChange={(e) => setForm((prev) => ({ ...prev, front: e.target.value }))}
className="min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:ring-2 focus-visible:ring-ring"
maxLength={200}
required
/>
}
/>
<Field
label="Back"
error={errors.back}
input={
<textarea
value={form.back}
onChange={(e) => setForm((prev) => ({ ...prev, back: e.target.value }))}
className="min-h-[120px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:ring-2 focus-visible:ring-ring"
maxLength={500}
required
/>
}
/>
<div className="flex justify-end gap-2">
<Button type="button" variant="outline" onClick={onClose}>
Anuluj
</Button>
<Button type="submit" disabled={submitting}>
{submitting ? "Zapisywanie..." : "Zapisz"}
</Button>
</div>
</form>
</Dialog>
);
}

function EditFlashcardDialog({
item,
isOpen,
onClose,
onUpdated,
}: {
item: FlashcardViewModel | null;
isOpen: boolean;
onClose: () => void;
onUpdated: (payload: { front?: string; back?: string }) => Promise<void>;
}) {
const [form, setForm] = useState<FlashcardFormState>(defaultFormState);
const [errors, setErrors] = useState<Partial<Record<keyof FlashcardFormState, string>>>({});
const [submitting, setSubmitting] = useState(false);

useEffect(() => {
if (item && isOpen) {
setForm({
front: item.front,
back: item.back,
});
setErrors({});
}
}, [item, isOpen]);

const handleSubmit = async (event: React.FormEvent) => {
event.preventDefault();
if (!item) return;
const validation = validateForm(form);
setErrors(validation);
if (Object.keys(validation).length > 0) return;
setSubmitting(true);
try {
await onUpdated({
front: form.front.trim(),
back: form.back.trim(),
});
} catch (err) {
setErrors({ front: err instanceof Error ? err.message : "Nie udało się zaktualizować" });
} finally {
setSubmitting(false);
}
};

if (!isOpen || !item) return null;

return (

<Dialog onClose={onClose} title="Edytuj fiszkę">
<form className="space-y-4" onSubmit={handleSubmit}>
<Field
label="Front"
error={errors.front}
input={
<textarea
value={form.front}
onChange={(e) => setForm((prev) => ({ ...prev, front: e.target.value }))}
className="min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:ring-2 focus-visible:ring-ring"
maxLength={200}
required
/>
}
/>
<Field
label="Back"
error={errors.back}
input={
<textarea
value={form.back}
onChange={(e) => setForm((prev) => ({ ...prev, back: e.target.value }))}
className="min-h-[120px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:ring-2 focus-visible:ring-ring"
maxLength={500}
required
/>
}
/>
<div className="flex justify-end gap-2">
<Button type="button" variant="outline" onClick={onClose}>
Anuluj
</Button>
<Button type="submit" disabled={submitting}>
{submitting ? "Zapisywanie..." : "Zapisz zmiany"}
</Button>
</div>
</form>
</Dialog>
);
}

function DeleteFlashcardDialog({
item,
isOpen,
onClose,
onDeleted,
}: {
item: FlashcardViewModel | null;
isOpen: boolean;
onClose: () => void;
onDeleted: () => Promise<void>;
}) {
const [submitting, setSubmitting] = useState(false);

const handleDelete = async () => {
if (!item) return;
setSubmitting(true);
try {
await onDeleted();
} finally {
setSubmitting(false);
}
};

if (!isOpen || !item) return null;

return (

<Dialog onClose={onClose} title="Usuń fiszkę">
<div className="space-y-4">
<p className="text-sm text-muted-foreground">Czy na pewno chcesz usunąć tę fiszkę?</p>
<p className="rounded-md border bg-muted/40 px-3 py-2 text-sm">{item.front}</p>
<div className="flex justify-end gap-2">
<Button type="button" variant="outline" onClick={onClose}>
Anuluj
</Button>
<Button type="button" variant="destructive" disabled={submitting} onClick={handleDelete}>
{submitting ? "Usuwanie..." : "Usuń"}
</Button>
</div>
</div>
</Dialog>
);
}

function Field({ label, error, input }: { label: string; error?: string; input: React.ReactNode }) {
return (
<label className="flex w-full flex-col gap-1 text-sm">
<span className="font-medium text-foreground">{label}</span>
{input}
{error ? <span className="text-xs text-destructive">{error}</span> : null}
</label>
);
}

function Dialog({ title, children, onClose }: { title: string; children: React.ReactNode; onClose: () => void }) {
useEffect(() => {
const handler = (event: KeyboardEvent) => {
if (event.key === "Escape") onClose();
};
window.addEventListener("keydown", handler);
return () => window.removeEventListener("keydown", handler);
}, [onClose]);

return (

<div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
<div className="w-full max-w-lg rounded-xl border bg-card p-5 shadow-lg">
<div className="mb-4 flex items-start justify-between gap-2">
<div>
<p className="text-sm text-muted-foreground">Formularz</p>
<h2 className="text-lg font-semibold text-foreground">{title}</h2>
</div>
<button
            type="button"
            className="rounded-full p-1 text-muted-foreground transition hover:bg-muted"
            onClick={onClose}
            aria-label="Zamknij"
          >
✕
</button>
</div>
{children}
</div>
</div>
);
}

function InlineAlert({ message, onRetry }: { message: string; onRetry: () => void }) {
return (

<div className="flex items-center justify-between gap-3 rounded-md border border-destructive/40 bg-destructive/5 px-4 py-2 text-sm text-destructive">
<span className="line-clamp-2">{message}</span>
<Button size="sm" variant="outline" onClick={onRetry}>
Spróbuj ponownie
</Button>
</div>
);
}

type ToastKind = "success" | "error";

function useToastHost() {
const [toasts, setToasts] = useState<{ id: string; message: string; type: ToastKind }[]>([]);

const addToast = useCallback((toast: { message: string; type: ToastKind }) => {
const id = crypto.randomUUID();
setToasts((prev) => [...prev, { id, ...toast }]);
setTimeout(() => {
setToasts((prev) => prev.filter((t) => t.id !== id));
}, 3200);
}, []);

const ToastHost = useCallback(() => {
if (toasts.length === 0) return null;
return (

<div className="pointer-events-none fixed inset-x-0 top-4 z-50 flex flex-col items-center gap-2 px-4">
{toasts.map((toast) => (
<div
key={toast.id}
className={cn(
"pointer-events-auto w-full max-w-sm rounded-lg border px-4 py-3 shadow-md backdrop-blur-sm transition",
toast.type === "success"
? "border-emerald-200/80 bg-emerald-50 text-emerald-900"
: "border-destructive/40 bg-destructive/10 text-destructive"
)} >
{toast.message}
</div>
))}
</div>
);
}, [toasts]);

return { addToast, ToastHost };
}

function ProgressIndicator({ total, visible, isLoading }: { total: number; visible: boolean; isLoading: boolean }) {
if (!visible) return null;
return (

<div className="flex items-center gap-2 text-sm text-muted-foreground">
<span>{`Łącznie: ${total}`}</span>
{isLoading ? (
<span className="inline-flex items-center gap-1" aria-label="Ładowanie">
<span className="h-2 w-2 animate-pulse rounded-full bg-primary" />
<span className="h-2 w-2 animate-pulse rounded-full bg-primary/70" />
<span className="h-2 w-2 animate-pulse rounded-full bg-primary/40" />
</span>
) : null}
</div>
);
}

function EmptyState({ onCreate, onGenerate }: { onCreate: () => void; onGenerate: () => void }) {
return (

<div className="flex flex-col items-center justify-center gap-3 rounded-xl border bg-card px-6 py-10 text-center shadow-sm">
<p className="text-base font-medium">Nie masz jeszcze żadnych fiszek.</p>
<p className="text-sm text-muted-foreground">Utwórz własne lub wygeneruj je automatycznie.</p>
<div className="flex flex-wrap justify-center gap-2">
<Button variant="outline" onClick={onGenerate}>
Generuj
</Button>
<Button onClick={onCreate}>Utwórz</Button>
</div>
</div>
);
}

function FilterPill({
active,
children,
onClick,
}: {
active: boolean;
children: React.ReactNode;
onClick: () => void;
}) {
return (
<button
type="button"
onClick={onClick}
className={cn(
"rounded-full border px-3 py-1 text-sm transition",
active
? "border-primary bg-primary/10 text-primary shadow-xs"
: "border-input bg-background text-foreground hover:border-ring hover:bg-accent"
)} >
{children}
</button>
);
}

function useInfiniteScroll({ canLoad, onLoadMore }: { canLoad: boolean; onLoadMore: () => void }) {
const ref = useRef<HTMLDivElement | null>(null);

useEffect(() => {
const node = ref.current;
if (!node || !canLoad) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && canLoad) {
            onLoadMore();
          }
        });
      },
      {
        rootMargin: "0px 0px 160px 0px",
        threshold: 0.5,
      }
    );

    observer.observe(node);
    return () => observer.disconnect();

}, [canLoad, onLoadMore]);

return ref;
}

================================================
FILE: src/components/generate/GeneratePage.tsx
================================================
import { useCallback, useMemo, useState } from "react";

import { createGenerationClient } from "@/lib/api/generations.client";
import { useGenerateState } from "../hooks/useGenerateState";
import type { GenerationStep } from "./types";
import { Step1Input } from "./Step1Input";
import { Step2Proposals } from "./Step2Proposals";

export default function GeneratePage() {
const { state, setText, setStep, setProposals, setGenerationId, updateProposal, reset } = useGenerateState();
const [isGenerating, setIsGenerating] = useState(false);
const [toast, setToast] = useState<{ message: string; tone: "success" | "error" } | null>(null);

const handleGenerated = useCallback(
async (text: string) => {
setIsGenerating(true);
setToast(null);
try {
const { generation, proposals } = await createGenerationClient({
payload: { text, model: "gpt-4o-mini" },
});
setText(text);
setGenerationId(generation.id ?? null);
setProposals(proposals);
setStep(2);
setToast({ message: "Wygenerowano propozycje fiszek", tone: "success" });
} catch (error) {
setToast({
message: error instanceof Error ? error.message : "Nie udało się wygenerować propozycji",
tone: "error",
});
} finally {
setIsGenerating(false);
}
},
[setGenerationId, setProposals, setStep, setText]
);

const handleReset = useCallback(() => {
reset();
}, [reset]);

return (

<div className="min-h-screen bg-background text-foreground">
<div className="mx-auto flex max-w-5xl flex-col gap-8 px-4 py-8">
<header className="space-y-2">
<p className="text-sm text-muted-foreground">Generuj fiszki</p>
<h1 className="text-3xl font-semibold leading-tight">Przygotuj tekst i wygeneruj propozycje</h1>
<p className="max-w-3xl text-sm text-muted-foreground">
Wklej tekst źródłowy, a następnie przejrzyj wygenerowane propozycje fiszek. Ten widok jest w trakcie
wdrażania – zaczynamy od kroku 1 i struktury całego procesu.
</p>
</header>

        <Stepper currentStep={state.step} />

        <section className="rounded-2xl border bg-card px-6 py-6 shadow-sm">
          {state.step === 1 ? (
            <Step1Input
              text={state.text}
              onTextChange={setText}
              onSubmit={handleGenerated}
              isSubmitting={isGenerating}
            />
          ) : (
            <Step2Proposals
              proposals={state.proposals}
              generationId={state.generationId ?? null}
              onUpdate={updateProposal}
              onSetProposals={setProposals}
              onReset={handleReset}
              onDone={() => {
                setToast({ message: "Zapisano fiszki, wróć do listy", tone: "success" });
                window.location.href = "/";
              }}
            />
          )}
        </section>
        {toast ? <InlineToast message={toast.message} tone={toast.tone} onClose={() => setToast(null)} /> : null}
      </div>
    </div>

);
}

function Stepper({ currentStep }: { currentStep: GenerationStep }) {
const steps = useMemo(
() => [
{ id: 1 as GenerationStep, label: "Tekst" },
{ id: 2 as GenerationStep, label: "Propozycje" },
],
[]
);

return (

<ol className="grid grid-cols-2 gap-3">
{steps.map((step) => {
const isActive = step.id === currentStep;
const isCompleted = step.id < currentStep;
const tone = isActive ? "border-ring bg-accent text-foreground" : "border-input bg-muted text-muted-foreground";
return (
<li key={step.id} className={`flex items-center gap-3 rounded-xl border px-4 py-3 ${tone}`}>
<span
className={`flex size-9 items-center justify-center rounded-full border text-sm font-semibold ${
                isCompleted || isActive
                  ? "border-ring bg-primary text-primary-foreground"
                  : "border-input bg-background"
              }`}
aria-hidden >
{step.id}
</span>
<div className="flex flex-col">
<span className="text-sm font-medium leading-tight">{step.label}</span>
<span className="text-xs text-muted-foreground">
{step.id === 1 ? "Wklej i zweryfikuj tekst" : "Przejrzyj propozycje (w przygotowaniu)"}
</span>
</div>
</li>
);
})}
</ol>
);
}

function InlineToast({ message, tone, onClose }: { message: string; tone: "success" | "error"; onClose: () => void }) {
const bg =
tone === "success"
? "border-emerald-200/80 bg-emerald-50 text-emerald-900"
: "border-destructive/40 bg-destructive/10 text-destructive";
return (

<div className="fixed inset-x-0 top-4 z-50 flex justify-center">
<div
className={`flex items-center gap-3 rounded-lg border px-4 py-3 text-sm shadow-md backdrop-blur-sm ${bg}`}
role="status" >
<span>{message}</span>
<button
          type="button"
          className="text-muted-foreground transition hover:text-foreground"
          onClick={onClose}
          aria-label="Zamknij powiadomienie"
        >
✕
</button>
</div>
</div>
);
}

================================================
FILE: src/components/generate/Step1Input.tsx
================================================
import { useCallback, useMemo, useState } from "react";

import { Button } from "@/components/ui/button";
import { useCharacterCounter, MAX_TEXT_LENGTH, MIN_TEXT_LENGTH } from "../hooks/useCharacterCounter";

interface Step1InputProps {
text: string;
onTextChange: (value: string) => void;
onSubmit: (value: string) => void;
isSubmitting?: boolean;
}

export function Step1Input({ text, onTextChange, onSubmit, isSubmitting }: Step1InputProps) {
const [wasTouched, setWasTouched] = useState(false);
const { length, isTooShort, isTooLong, isValid } = useCharacterCounter(text);
const shouldValidate = wasTouched;

const validationMessage = useMemo(() => {
if (!shouldValidate) {
return "Wklej tekst (1 000–10 000 znaków) i przejdź dalej.";
}
if (isTooShort) {
return `Wklej co najmniej ${MIN_TEXT_LENGTH} znaków`;
}
if (isTooLong) {
return `Tekst może mieć maksymalnie ${MAX_TEXT_LENGTH} znaków`;
}
return "Tekst wygląda dobrze. Przejdź dalej, aby wygenerować fiszki.";
}, [isTooLong, isTooShort, shouldValidate]);

const handleTextChange = useCallback(
(value: string) => {
if (!wasTouched) {
setWasTouched(true);
}
onTextChange(value);
},
[onTextChange, wasTouched]
);

const handleSubmit = useCallback(
(event: React.FormEvent<HTMLFormElement>) => {
event.preventDefault();
if (!wasTouched) {
setWasTouched(true);
}
if (!isValid) {
return;
}
onSubmit(text);
},
[isValid, onSubmit, text, wasTouched]
);

return (

<form className="space-y-4" onSubmit={handleSubmit} aria-labelledby="generate-step1-title">
<div className="space-y-2">
<p className="text-sm text-muted-foreground">Krok 1 z 2</p>
<h2 id="generate-step1-title" className="text-2xl font-semibold text-foreground">
Wklej tekst źródłowy
</h2>
<p className="text-sm text-muted-foreground">
Wprowadź tekst na podstawie którego zostaną zaproponowane fiszki.
</p>
</div>

      <div className="space-y-3">
        <TextareaWithCounter
          value={text}
          onChange={handleTextChange}
          count={length}
          isTooShort={isTooShort}
          isTooLong={isTooLong}
          shouldValidate={shouldValidate}
        />
        <ValidationMessage isValid={isValid} message={validationMessage} shouldValidate={shouldValidate} />
      </div>

      <div className="flex flex-wrap items-center gap-3">
        <Button type="submit" disabled={!isValid || isSubmitting}>
          {isSubmitting ? "Generowanie..." : "Dalej"}
        </Button>
      </div>
    </form>

);
}

function TextareaWithCounter({
value,
onChange,
count,
isTooShort,
isTooLong,
shouldValidate,
}: {
value: string;
onChange: (value: string) => void;
count: number;
isTooShort: boolean;
isTooLong: boolean;
shouldValidate: boolean;
}) {
const statusColor =
shouldValidate && (isTooShort || isTooLong) ? "border-destructive focus-visible:ring-destructive" : "border-input";

return (
<label className="block space-y-2">
<span className="text-sm font-medium text-foreground">Tekst do analizy</span>
<textarea
className={`min-h-[240px] w-full rounded-xl border bg-background px-4 py-3 text-base text-foreground shadow-xs outline-none transition focus-visible:ring-2 ${statusColor}`}
value={value}
onChange={(event) => onChange(event.target.value)}
aria-invalid={shouldValidate && (isTooShort || isTooLong)}
aria-describedby="generate-text-help"
maxLength={MAX_TEXT_LENGTH}
placeholder="Wklej tekst (1 000–10 000 znaków)..."
/>

<div className="flex items-center justify-between text-sm text-muted-foreground" id="generate-text-help">
<span>{count} znaków</span>
<span>
Limit znaków: {MIN_TEXT_LENGTH} – {MAX_TEXT_LENGTH}
</span>
</div>
</label>
);
}

function ValidationMessage({
isValid,
message,
shouldValidate,
}: {
isValid: boolean;
message: string;
shouldValidate: boolean;
}) {
const tone = !shouldValidate ? "text-muted-foreground" : isValid ? "text-emerald-600" : "text-destructive";
return <p className={`text-sm ${tone}`}>{message}</p>;
}

================================================
FILE: src/components/generate/Step2Proposals.tsx
================================================
import { useCallback, useMemo, useState } from "react";

import { Button } from "@/components/ui/button";
import { cn } from "@/lib/utils";
import type { BulkCreateFlashcardsCommand, SourceEnum } from "@/types";
import { bulkCreateFlashcardsClient } from "@/lib/api/flashcards.client";
import type { FlashcardProposal } from "./types";
import { CheckCircle2, XCircle } from "lucide-react";

interface Step2ProposalsProps {
generationId: string | null;
proposals: FlashcardProposal[];
onUpdate: (id: string, patch: Partial<FlashcardProposal>) => void;
onSetProposals: (next: FlashcardProposal[]) => void;
onDone: () => void;
onReset: () => void;
}

export function Step2Proposals({
generationId,
proposals,
onUpdate,
onSetProposals,
onDone,
onReset,
}: Step2ProposalsProps) {
const [editing, setEditing] = useState<FlashcardProposal | null>(null);
const [isSaving, setIsSaving] = useState(false);
const [toast, setToast] = useState<{ message: string; tone: "success" | "error" } | null>(null);

const handleAccept = useCallback(
(id: string) => {
onUpdate(id, { state: "accepted" });
},
[onUpdate]
);

const handleReject = useCallback(
(id: string) => {
onUpdate(id, { state: "rejected" });
},
[onUpdate]
);

const handleResetStatus = useCallback(
(id: string) => {
onUpdate(id, { state: "pending" });
},
[onUpdate]
);

const handleEditSave = useCallback(
(id: string, front: string, back: string) => {
onUpdate(id, { front, back, state: "edited" });
setEditing(null);
},
[onUpdate]
);

const acceptedCount = useMemo(() => proposals.filter((p) => p.state === "accepted").length, [proposals]);
const rejectedCount = useMemo(() => proposals.filter((p) => p.state === "rejected").length, [proposals]);
const hasSavable = useMemo(() => proposals.some((p) => p.state !== "rejected"), [proposals]);

const handleAcceptAll = useCallback(async () => {
const toSave = proposals.filter((proposal) => proposal.state !== "rejected");
if (toSave.length === 0) {
setToast({ message: "Brak kart do zapisania", tone: "error" });
return;
}

    const payload: BulkCreateFlashcardsCommand = {
      generationId: generationId ?? null,
      flashcards: toSave.map((proposal) => ({
        front: proposal.front,
        back: proposal.back,
        source: proposal.state === "edited" ? ("ai_edited" as SourceEnum) : ("ai_generated" as SourceEnum),
      })),
    };

    setIsSaving(true);
    try {
      await bulkCreateFlashcardsClient({ payload });
      setToast({ message: "Zapisano fiszki", tone: "success" });
      onSetProposals([]);
      onDone();
    } catch (error) {
      setToast({
        message: error instanceof Error ? error.message : "Nie udało się zapisać fiszek",
        tone: "error",
      });
    } finally {
      setIsSaving(false);
    }

}, [generationId, onDone, onSetProposals, proposals]);

return (

<div className="space-y-6">
<div className="space-y-2">
<p className="text-sm text-muted-foreground">Krok 2 z 2</p>
<div className="flex flex-wrap items-center justify-between gap-3">
<div>
<h2 className="text-2xl font-semibold text-foreground">Propozycje AI</h2>
<p className="text-sm text-muted-foreground">
Zweryfikuj, edytuj lub odrzuć. Następnie zapisz zaakceptowane fiszki.
</p>
</div>
<div className="flex items-center gap-2 text-xs text-muted-foreground">
<Tag label={`Akceptowane: ${acceptedCount}`} />
<Tag label={`Odrzucone: ${rejectedCount}`} />
</div>
</div>
</div>

      <div className="flex flex-wrap items-center justify-between gap-3">
        <div className="text-sm text-muted-foreground">Karty do weryfikacji: {proposals.length}</div>
        <div className="flex flex-wrap gap-2">
          <Button variant="ghost" onClick={onReset}>
            Zacznij od nowa
          </Button>
          <Button onClick={handleAcceptAll} disabled={!hasSavable || isSaving}>
            {isSaving ? "Zapisywanie..." : "Zapisz"}
          </Button>
        </div>
      </div>

      {proposals.length === 0 ? (
        <EmptyState onReset={onReset} />
      ) : (
        <AIFlashcardGrid
          proposals={proposals}
          onAccept={handleAccept}
          onReject={handleReject}
          onEdit={setEditing}
          onResetStatus={handleResetStatus}
        />
      )}

      {editing ? (
        <EditDialog proposal={editing} onClose={() => setEditing(null)} onSave={handleEditSave} isSaving={isSaving} />
      ) : null}

      {toast ? <InlineToast message={toast.message} tone={toast.tone} onClose={() => setToast(null)} /> : null}
    </div>

);
}

function AIFlashcardGrid({
proposals,
onAccept,
onReject,
onEdit,
onResetStatus,
}: {
proposals: FlashcardProposal[];
onAccept: (id: string) => void;
onReject: (id: string) => void;
onEdit: (proposal: FlashcardProposal) => void;
onResetStatus: (id: string) => void;
}) {
return (

<div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
{proposals.map((proposal) => (
<FlashcardCard
          key={proposal.id}
          proposal={proposal}
          onAccept={onAccept}
          onReject={onReject}
          onEdit={onEdit}
          onResetStatus={onResetStatus}
        />
))}
</div>
);
}

function FlashcardCard({
proposal,
onAccept,
onReject,
onEdit,
onResetStatus,
}: {
proposal: FlashcardProposal;
onAccept: (id: string) => void;
onReject: (id: string) => void;
onEdit: (proposal: FlashcardProposal) => void;
onResetStatus: (id: string) => void;
}) {
const isAccepted = proposal.state === "accepted";
const isRejected = proposal.state === "rejected";
const isReviewed = isAccepted || isRejected;

return (

<article className="group flex h-full flex-col justify-between rounded-xl border bg-card p-4 shadow-sm transition hover:border-ring hover:bg-accent">
<div className="space-y-2">
<p className="line-clamp-3 text-base font-semibold leading-tight text-foreground">{proposal.front}</p>
<p className="line-clamp-4 text-sm text-muted-foreground">{proposal.back}</p>
</div>
<div className="mt-4 flex items-center gap-2">
{isReviewed ? (
<>
<StatusBadge state={proposal.state} />
<Button size="sm" variant="outline" onClick={() => onResetStatus(proposal.id)}>
Zmień
</Button>
</>
) : (
<>
<Button size="sm" variant="outline" onClick={() => onEdit(proposal)}>
Edytuj
</Button>
<Button size="sm" variant="secondary" onClick={() => onReject(proposal.id)}>
Odrzuć
</Button>
<Button size="sm" onClick={() => onAccept(proposal.id)}>
Akceptuj
</Button>
</>
)}
</div>
</article>
);
}

function EditDialog({
proposal,
onClose,
onSave,
isSaving,
}: {
proposal: FlashcardProposal;
onClose: () => void;
onSave: (id: string, front: string, back: string) => void;
isSaving: boolean;
}) {
const [front, setFront] = useState(proposal.front);
const [back, setBack] = useState(proposal.back);
const [errors, setErrors] = useState<{ front?: string; back?: string }>({});

const validate = useCallback(() => {
const next: { front?: string; back?: string } = {};
if (!front.trim() || front.trim().length > 200) {
next.front = "Front musi mieć 1-200 znaków";
}
if (!back.trim() || back.trim().length > 500) {
next.back = "Back musi mieć 1-500 znaków";
}
setErrors(next);
return Object.keys(next).length === 0;
}, [back, front]);

const handleSubmit = useCallback(
(event: React.FormEvent) => {
event.preventDefault();
if (!validate()) return;
onSave(proposal.id, front.trim(), back.trim());
},
[back, front, onSave, proposal.id, validate]
);

return (

<div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4">
<div className="w-full max-w-lg rounded-xl border bg-card p-5 shadow-lg">
<div className="mb-4 flex items-center justify-between">
<div>
<p className="text-sm text-muted-foreground">Edycja fiszki</p>
<h3 className="text-lg font-semibold text-foreground">Popraw treść</h3>
</div>
<button
            type="button"
            className="rounded-full p-1 text-muted-foreground transition hover:bg-muted"
            onClick={onClose}
            aria-label="Zamknij"
          >
✕
</button>
</div>

        <form className="space-y-4" onSubmit={handleSubmit}>
          <Field label="Front" error={errors.front}>
            <textarea
              value={front}
              onChange={(e) => setFront(e.target.value)}
              className={cn(
                "min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:ring-2 focus-visible:ring-ring",
                errors.front ? "border-destructive" : "border-input"
              )}
              maxLength={200}
              required
            />
          </Field>
          <Field label="Back" error={errors.back}>
            <textarea
              value={back}
              onChange={(e) => setBack(e.target.value)}
              className={cn(
                "min-h-[120px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm outline-none focus-visible:ring-2 focus-visible:ring-ring",
                errors.back ? "border-destructive" : "border-input"
              )}
              maxLength={500}
              required
            />
          </Field>
          <div className="flex justify-end gap-2">
            <Button type="button" variant="outline" onClick={onClose}>
              Anuluj
            </Button>
            <Button type="submit" disabled={isSaving}>
              {isSaving ? "Zapisywanie..." : "Zapisz zmiany"}
            </Button>
          </div>
        </form>
      </div>
    </div>

);
}

function Field({ label, error, children }: { label: string; error?: string; children: React.ReactNode }) {
return (
<label className="flex w-full flex-col gap-1 text-sm">
<span className="font-medium text-foreground">{label}</span>
{children}
{error ? <span className="text-xs text-destructive">{error}</span> : null}
</label>
);
}

function InlineToast({ message, tone, onClose }: { message: string; tone: "success" | "error"; onClose: () => void }) {
const bg =
tone === "success"
? "border-emerald-200/80 bg-emerald-50 text-emerald-900"
: "border-destructive/40 bg-destructive/10 text-destructive";
return (

<div className="fixed inset-x-0 top-4 z-50 flex justify-center">
<div
className={cn("flex items-center gap-3 rounded-lg border px-4 py-3 text-sm shadow-md backdrop-blur-sm", bg)}
role="status" >
<span>{message}</span>
<button
          type="button"
          className="text-muted-foreground transition hover:text-foreground"
          onClick={onClose}
          aria-label="Zamknij powiadomienie"
        >
✕
</button>
</div>
</div>
);
}

function EmptyState({ onReset }: { onReset: () => void }) {
return (

<div className="flex flex-col items-center justify-center gap-3 rounded-xl border bg-muted/30 px-6 py-10 text-center">
<p className="text-base font-medium">Brak widocznych propozycji.</p>
<p className="text-sm text-muted-foreground">Wróć do tekstu źródłowego lub odśwież generację.</p>
<div className="flex gap-2">
<Button variant="outline" onClick={onReset}>
Zacznij od nowa
</Button>
<Button onClick={onReset}>Wygeneruj ponownie</Button>
</div>
</div>
);
}

function Tag({ label }: { label: string }) {
return (
<span className="rounded-full border border-input bg-muted px-3 py-1 text-xs text-muted-foreground">{label}</span>
);
}

function StatusBadge({ state }: { state: FlashcardProposal["state"] }) {
const isAccepted = state === "accepted";
const tone = isAccepted
? "border-emerald-200 bg-emerald-50 text-emerald-800"
: "border-destructive/40 bg-destructive/10 text-destructive";
const Icon = isAccepted ? CheckCircle2 : XCircle;
const label = isAccepted ? "Zaakceptowano" : "Odrzucono";

return (
<span className={cn("inline-flex items-center gap-1 rounded-full border px-3 py-1 text-xs font-medium", tone)}>
<Icon className="h-4 w-4" aria-hidden />
{label}
</span>
);
}

================================================
FILE: src/components/generate/types.ts
================================================
export type ProposalState = "pending" | "accepted" | "edited" | "rejected";

export interface FlashcardProposal {
id: string;
front: string;
back: string;
state: ProposalState;
}

export type GenerationStep = 1 | 2;

export interface GenerateViewState {
step: GenerationStep;
text: string;
proposals: FlashcardProposal[];
generationId: string | null;
}

================================================
FILE: src/components/hooks/useCharacterCounter.ts
================================================
import { useMemo } from "react";

export const MIN_TEXT_LENGTH = 1000;
export const MAX_TEXT_LENGTH = 10000;

interface CounterResult {
length: number;
isTooShort: boolean;
isTooLong: boolean;
isValid: boolean;
}

export function useCharacterCounter(value: string, min = MIN_TEXT_LENGTH, max = MAX_TEXT_LENGTH): CounterResult {
return useMemo(() => {
const length = value?.length ?? 0;
const isTooShort = length < min;
const isTooLong = length > max;
return {
length,
isTooShort,
isTooLong,
isValid: !isTooShort && !isTooLong,
};
}, [max, min, value]);
}

================================================
FILE: src/components/hooks/useFlashcardsList.ts
================================================
import { useCallback, useEffect, useRef, useState } from "react";

import type { SourceEnum } from "../../types";
import {
fetchFlashcardsList,
type CreateFlashcardArgs,
type DeleteFlashcardArgs,
type FetchFlashcardsListArgs,
type UpdateFlashcardArgs,
createFlashcardClient,
deleteFlashcardClient,
updateFlashcardClient,
} from "../../lib/api/flashcards.client";
import {
DEFAULT_FLASHCARD_PAGE_SIZE,
type FlashcardListQueryVM,
type FlashcardViewModel,
type SortOption,
} from "../../lib/view-models/flashcards";

interface UseFlashcardsListOptions {
pageSize?: number;
initialSource?: SourceEnum;
initialSort?: SortOption;
}

export function useFlashcardsList(options?: UseFlashcardsListOptions) {
const sourceRef = useRef<SourceEnum | undefined>(options?.initialSource);
const sortRef = useRef<SortOption>(options?.initialSort ?? "created_at desc");
const [items, setItems] = useState<FlashcardViewModel[]>([]);
const itemsRef = useRef<FlashcardViewModel[]>([]);
const [page, setPage] = useState(1);
const [pageSize] = useState(options?.pageSize ?? DEFAULT_FLASHCARD_PAGE_SIZE);
const [total, setTotal] = useState(0);
const [source, setSource] = useState<SourceEnum | undefined>(sourceRef.current);
const [sort, setSort] = useState<SortOption>(sortRef.current);
const [isLoading, setIsLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const [hasMore, setHasMore] = useState(false);

const abortRef = useRef<AbortController | null>(null);
const isFetchingRef = useRef(false);
const pageRef = useRef(1);

const updateListState = useCallback(
(nextItems: FlashcardViewModel[], nextPage: number, totalCount: number) => {
setItems(nextItems);
itemsRef.current = nextItems;
setTotal(totalCount);
setPage(nextPage);
pageRef.current = nextPage;
const moreByTotal = nextPage _ pageSize < totalCount;
const moreByPageSize = nextItems.length >= nextPage _ pageSize && nextItems.length % pageSize === 0;
setHasMore(moreByTotal || moreByPageSize);
},
[pageSize]
);

const fetchPage = useCallback(
async ({
targetPage,
reset = false,
nextSource,
nextSort,
signal,
}: { targetPage: number; reset?: boolean; nextSource?: SourceEnum; nextSort?: SortOption } & Pick<
FetchFlashcardsListArgs,
"signal" >) => {
if (isFetchingRef.current && !reset) {
return;
}

      abortRef.current?.abort();
      const controller = new AbortController();
      abortRef.current = controller;

      isFetchingRef.current = true;
      setIsLoading(true);
      setError(null);

      try {
        const resolvedSource = reset ? nextSource : (nextSource ?? sourceRef.current);
        const resolvedSort = reset ? (nextSort ?? sortRef.current) : (nextSort ?? sortRef.current);

        const pageData = await fetchFlashcardsList({
          page: targetPage,
          pageSize,
          source: resolvedSource,
          sort: resolvedSort,
          signal: controller.signal ?? signal,
        });

        if (controller.signal.aborted) {
          return;
        }

        const currentItems = itemsRef.current;
        const merged = reset ? pageData.items : dedupeById([...currentItems, ...pageData.items]);
        updateListState(merged, pageData.page, pageData.total);
        sourceRef.current = resolvedSource;
        sortRef.current = resolvedSort;
        setSource(resolvedSource);
        setSort(resolvedSort);
      } catch (err) {
        if (controller.signal.aborted) {
          return;
        }
        const message = err instanceof Error ? err.message : "Wystąpił nieoczekiwany błąd";
        setError(message);
      } finally {
        if (!controller.signal.aborted) {
          setIsLoading(false);
        }
        isFetchingRef.current = false;
      }
    },
    [pageSize, updateListState]

);

const loadInitial = useCallback(async () => {
return fetchPage({ targetPage: 1, reset: true });
}, [fetchPage]);

const loadMore = useCallback(async () => {
if (isLoading || !hasMore) {
return;
}
const nextPage = pageRef.current + 1;
return fetchPage({ targetPage: nextPage, reset: false });
}, [fetchPage, hasMore, isLoading]);

const applySource = useCallback(
async (nextSource?: SourceEnum) => {
return fetchPage({ targetPage: 1, reset: true, nextSource });
},
[fetchPage]
);

const applySort = useCallback(
async (nextSort: SortOption) => {
return fetchPage({ targetPage: 1, reset: true, nextSort });
},
[fetchPage]
);

const prepend = useCallback(
(item: FlashcardViewModel) => {
const nextItems = dedupeById([item, ...items]);
updateListState(nextItems, 1, Math.max(total + 1, nextItems.length));
},
[items, total, updateListState]
);

const updateOne = useCallback(
(item: FlashcardViewModel) => {
const nextItems = items.map((current) => (current.id === item.id ? item : current));
setItems(nextItems);
},
[items]
);

const removeOne = useCallback(
(id: string) => {
const nextItems = items.filter((item) => item.id !== id);
updateListState(nextItems, pageRef.current, Math.max(0, total - 1));
},
[items, total, updateListState]
);

const createOne = useCallback(
async (args: CreateFlashcardArgs) => {
const controller = new AbortController();
const viewModel = await createFlashcardClient({ ...args, signal: controller.signal });
prepend(viewModel);
return viewModel;
},
[prepend]
);

const updateRemote = useCallback(
async (args: UpdateFlashcardArgs) => {
const controller = new AbortController();
const updated = await updateFlashcardClient({ ...args, signal: controller.signal });
updateOne(updated);
return updated;
},
[updateOne]
);

const deleteRemote = useCallback(
async (args: DeleteFlashcardArgs) => {
const controller = new AbortController();
await deleteFlashcardClient({ ...args, signal: controller.signal });
removeOne(args.id);
},
[removeOne]
);

useEffect(() => {
loadInitial();
return () => abortRef.current?.abort();
}, [loadInitial]);

const query: FlashcardListQueryVM = {
page,
pageSize,
source,
sort,
};

return {
items,
page,
pageSize,
total,
source,
sort,
isLoading,
hasMore,
error,
loadInitial,
loadMore,
applySource,
applySort,
prepend,
updateOne,
removeOne,
createOne,
updateRemote,
deleteRemote,
query,
};
}

function dedupeById(list: FlashcardViewModel[]): FlashcardViewModel[] {
const seen = new Set<string>();
const result: FlashcardViewModel[] = [];
for (const item of list) {
if (seen.has(item.id)) {
continue;
}
seen.add(item.id);
result.push(item);
}
return result;
}

================================================
FILE: src/components/hooks/useGenerateState.ts
================================================
import { useCallback, useReducer } from "react";

import type { FlashcardProposal, GenerateViewState, GenerationStep } from "../generate/types";

type Action =
| { type: "setText"; text: string }
| { type: "setStep"; step: GenerationStep }
| { type: "setProposals"; proposals: FlashcardProposal[] }
| { type: "updateProposal"; id: string; patch: Partial<FlashcardProposal> }
| { type: "removeProposal"; id: string }
| { type: "setGenerationId"; generationId: string | null }
| { type: "reset" };

const initialState: GenerateViewState = {
step: 1,
text: "",
proposals: [],
generationId: null,
};

function reducer(state: GenerateViewState, action: Action): GenerateViewState {
switch (action.type) {
case "setText":
return { ...state, text: action.text };
case "setStep":
return { ...state, step: action.step };
case "setProposals":
return { ...state, proposals: action.proposals };
case "updateProposal":
return {
...state,
proposals: state.proposals.map((proposal) =>
proposal.id === action.id ? { ...proposal, ...action.patch } : proposal
),
};
case "removeProposal":
return { ...state, proposals: state.proposals.filter((proposal) => proposal.id !== action.id) };
case "setGenerationId":
return { ...state, generationId: action.generationId };
case "reset":
return initialState;
default:
return state;
}
}

export function useGenerateState(initial?: Partial<GenerateViewState>) {
const [state, dispatch] = useReducer(reducer, { ...initialState, ...initial });

const setText = useCallback((text: string) => dispatch({ type: "setText", text }), []);
const setStep = useCallback((step: GenerationStep) => dispatch({ type: "setStep", step }), []);
const setProposals = useCallback(
(proposals: FlashcardProposal[]) => dispatch({ type: "setProposals", proposals }),
[]
);
const updateProposal = useCallback(
(id: string, patch: Partial<FlashcardProposal>) => dispatch({ type: "updateProposal", id, patch }),
[]
);
const removeProposal = useCallback((id: string) => dispatch({ type: "removeProposal", id }), []);
const setGenerationId = useCallback(
(generationId: string | null) => dispatch({ type: "setGenerationId", generationId }),
[]
);
const reset = useCallback(() => dispatch({ type: "reset" }), []);

return {
state,
setText,
setStep,
setProposals,
updateProposal,
removeProposal,
setGenerationId,
reset,
};
}

================================================
FILE: src/components/hooks/useThemeMode.ts
================================================
import { useCallback, useEffect, useMemo, useState } from "react";

import type { ThemeMode } from "@/types";

const STORAGE_KEY = "theme-mode";

const isValidThemeMode = (value: unknown): value is ThemeMode =>
value === "light" || value === "dark" || value === "system";

export function useThemeMode() {
const [mode, setModeState] = useState<ThemeMode>("system");
const [isSystemPreferredDark, setIsSystemPreferredDark] = useState(false);

useEffect(() => {
if (typeof window === "undefined") {
return;
}

    const media = window.matchMedia("(prefers-color-scheme: dark)");
    setIsSystemPreferredDark(media.matches);

    const storedMode = window.localStorage.getItem(STORAGE_KEY);
    if (isValidThemeMode(storedMode)) {
      setModeState(storedMode);
    }

    const handleMediaChange = (event: MediaQueryListEvent) => {
      setIsSystemPreferredDark(event.matches);
    };

    media.addEventListener("change", handleMediaChange);
    return () => media.removeEventListener("change", handleMediaChange);

}, []);

useEffect(() => {
if (typeof document === "undefined") {
return;
}

    const shouldUseDark = mode === "dark" || (mode === "system" && isSystemPreferredDark);
    const root = document.documentElement;
    root.classList.toggle("dark", shouldUseDark);
    root.setAttribute("data-theme", shouldUseDark ? "dark" : "light");

    try {
      window.localStorage.setItem(STORAGE_KEY, mode);
    } catch (error) {
      // eslint-disable-next-line no-console
      console.error("Failed to persist theme mode", error);
    }

}, [isSystemPreferredDark, mode]);

const setMode = useCallback((nextMode: ThemeMode) => {
if (!isValidThemeMode(nextMode)) {
return;
}
setModeState(nextMode);
}, []);

const effectiveMode = useMemo<ThemeMode>(() => {
if (mode === "system") {
return isSystemPreferredDark ? "dark" : "light";
}
return mode;
}, [isSystemPreferredDark, mode]);

return { mode, setMode, isSystemPreferredDark, effectiveMode };
}

================================================
FILE: src/components/learning/HotkeyHandler.tsx
================================================
import { useHotkeys } from "@/lib/hooks/useHotkeys";
import type { Grade } from "@/types";

interface HotkeyHandlerProps {
onFlip: () => void;
onScore: (grade: Grade) => void;
disabled?: boolean;
}

export function HotkeyHandler({ onFlip, onScore, disabled }: HotkeyHandlerProps) {
useHotkeys({ onFlip, onScore, enabled: !disabled });
return <div aria-hidden className="sr-only" />;
}

================================================
FILE: src/components/learning/LearningCard.tsx
================================================
import type { LearningCardVM } from "@/types";

interface LearningCardProps {
card: LearningCardVM;
onFlip: () => void;
}

export function LearningCard({ card, onFlip }: LearningCardProps) {
const showBack = card.flipped;
const isLocked = typeof card.grade === "number";

return (
<button
      type="button"
      onClick={onFlip}
      disabled={isLocked}
      aria-expanded={showBack}
      className="group relative w-full overflow-hidden rounded-2xl border bg-card px-6 py-10 text-left shadow-sm transition focus-visible:ring-2 focus-visible:ring-ring/60 focus-visible:outline-none disabled:cursor-not-allowed"
    >

<div className="absolute inset-0 pointer-events-none bg-gradient-to-b from-transparent via-transparent to-black/[0.02] dark:to-white/5" />
<div className="relative flex flex-col gap-5">
<div className="flex items-center justify-between text-xs font-medium uppercase tracking-wide text-muted-foreground">
<span>{showBack ? "Odpowiedź" : "Pytanie"}</span>
{isLocked ? (
<span className="rounded-full bg-muted px-2 py-0.5 text-[10px] text-muted-foreground">Oceniona</span>
) : null}
</div>
<div className="min-h-[160px] text-lg font-semibold leading-relaxed text-foreground">
{showBack ? (card.back ?? "Brak odpowiedzi. Ocena możliwa po sprawdzeniu.") : card.front}
</div>
<p className="text-sm text-muted-foreground">
Kliknij lub naciśnij Space/Enter, aby {showBack ? "wrócić do pytania" : "sprawdzić odpowiedź"}.
</p>
</div>
</button>
);
}

================================================
FILE: src/components/learning/LearningSession.tsx
================================================
import { useCallback, useEffect, useMemo, useState } from "react";

import { Button } from "@/components/ui/button";
import { useLearningSession } from "@/lib/hooks/useLearningSession";
import type { Grade } from "@/types";

import { HotkeyHandler } from "./HotkeyHandler";
import { LearningCard } from "./LearningCard";
import { ProgressCounter } from "./ProgressCounter";
import { ScoreButtons } from "./ScoreButtons";
import { SummaryModal } from "./SummaryModal";

export default function LearningSession() {
const { session, currentCard, stats, loading, error, fetchSession, flip, score } = useLearningSession();
const [showSummary, setShowSummary] = useState(false);

const hasCards = session.cards.length > 0;
const progressValue = useMemo(() => {
if (!hasCards) {
return 0;
}
if (session.finished) {
return session.cards.length;
}
return session.currentIndex + (currentCard?.grade ? 1 : 0);
}, [currentCard?.grade, hasCards, session.cards.length, session.currentIndex, session.finished]);

const handleScore = useCallback(
(grade: Grade) => {
score(grade);
},
[score]
);

useEffect(() => {
if (session.finished && session.cards.length > 0) {
setShowSummary(true);
}
}, [session.cards.length, session.finished]);

const handleRestart = useCallback(() => {
setShowSummary(false);
fetchSession().catch(() => {
/_ handled _/
});
}, [fetchSession]);

const handleDone = useCallback(() => {
window.location.href = "/";
}, []);

return (

<div className="min-h-screen bg-background text-foreground">
<div className="mx-auto flex max-w-5xl flex-col gap-8 px-4 py-8">
<header className="space-y-3">
<p className="text-sm text-muted-foreground">Sesja nauki</p>
<div className="flex flex-col gap-2">
<h1 className="text-3xl font-semibold leading-tight text-foreground">Powtarzaj fiszki i oceniaj postęp</h1>
<p className="max-w-3xl text-sm text-muted-foreground">
Użyj klawiatury, aby szybko odwracać karty (Space/Enter) i oceniać (0-5 lub strzałka w prawo = 5).
Przyciskaj kolejne fiszki, aż zobaczysz podsumowanie.
</p>
</div>
<div className="flex flex-wrap gap-2 text-xs text-muted-foreground">
<span className="rounded-full border px-2 py-1">Space/Enter → odkryj</span>
<span className="rounded-full border px-2 py-1">0-5 → ocena</span>
<span className="rounded-full border px-2 py-1">→ → maks. ocena</span>
<span className="rounded-full border px-2 py-1">← → przełącz pytanie/odpowiedź</span>
</div>
</header>

        {loading ? (
          <LoadingState />
        ) : error ? (
          <ErrorState message={error} onRetry={fetchSession} />
        ) : !hasCards ? (
          <EmptyState onRetry={fetchSession} />
        ) : (
          <section className="rounded-2xl border bg-card p-6 shadow-sm">
            <div className="flex flex-col gap-6">
              <ProgressCounter current={progressValue} total={session.cards.length} />
              {currentCard ? (
                <LearningCard card={currentCard} onFlip={flip} />
              ) : (
                <div className="rounded-xl border border-dashed p-6 text-center text-sm text-muted-foreground">
                  Brak bieżącej karty.
                </div>
              )}
              <div className="flex flex-col gap-4">
                <div className="flex flex-col gap-2 text-sm text-muted-foreground sm:flex-row sm:items-center sm:justify-between">
                  <span>Oceń kartę po sprawdzeniu odpowiedzi.</span>
                </div>
                <ScoreButtons
                  disabled={!currentCard?.flipped || typeof currentCard?.grade === "number"}
                  onScore={handleScore}
                />
              </div>
            </div>
          </section>
        )}
      </div>

      <HotkeyHandler onFlip={flip} onScore={handleScore} disabled={loading || showSummary || !hasCards} />

      <SummaryModal open={showSummary} stats={stats} onRestart={handleRestart} onDone={handleDone} />
    </div>

);
}

function LoadingState() {
return (

<div className="rounded-2xl border bg-card p-6 shadow-sm">
<div className="flex animate-pulse flex-col gap-4">
<div className="h-4 w-32 rounded bg-muted" />
<div className="h-40 rounded-2xl bg-muted" />
<div className="h-10 rounded bg-muted" />
</div>
</div>
);
}

function ErrorState({ message, onRetry }: { message: string; onRetry: () => Promise<void> | void }) {
return (

<div className="rounded-2xl border border-destructive/40 bg-destructive/5 p-6 text-destructive shadow-sm">
<div className="flex items-start justify-between gap-4">
<div>
<p className="text-sm font-semibold">Nie udało się załadować sesji</p>
<p className="text-sm text-destructive/80">{message}</p>
</div>
<Button variant="outline" onClick={onRetry}>
Spróbuj ponownie
</Button>
</div>
</div>
);
}

function EmptyState({ onRetry }: { onRetry: () => Promise<void> | void }) {
return (

<div className="rounded-2xl border bg-card p-10 text-center shadow-sm">
<h2 className="text-xl font-semibold text-foreground">Brak kart do nauki</h2>
<p className="mt-2 text-sm text-muted-foreground">
Wygląda na to, że nie ma fiszek spełniających kryteria. Dodaj nowe lub spróbuj ponownie.
</p>
<div className="mt-6 flex justify-center">
<Button onClick={onRetry}>Wczytaj ponownie</Button>
</div>
</div>
);
}

================================================
FILE: src/components/learning/ProgressCounter.tsx
================================================
interface ProgressCounterProps {
current: number;
total: number;
}

export function ProgressCounter({ current, total }: ProgressCounterProps) {
const percent = total > 0 ? Math.round((current / total) \* 100) : 0;

return (

<div className="flex flex-col gap-2">
<div className="flex items-baseline justify-between text-sm">
<span className="text-muted-foreground">Postęp</span>
<span className="font-semibold text-foreground">
{current} / {total}
</span>
</div>
<div className="h-2 rounded-full bg-muted">
<div
className="h-2 rounded-full bg-primary transition-all"
style={{ width: `${Math.min(100, percent)}%` }}
aria-hidden
/>
</div>
</div>
);
}

================================================
FILE: src/components/learning/ScoreButtons.tsx
================================================
import { Button } from "@/components/ui/button";
import type { Grade } from "@/types";

interface ScoreButtonsProps {
disabled?: boolean;
onScore: (grade: Grade) => void;
}

const scoreLabels: { grade: Grade; label: string }[] = [
{ grade: 0, label: "0" },
{ grade: 1, label: "1" },
{ grade: 2, label: "2" },
{ grade: 3, label: "3" },
{ grade: 4, label: "4" },
{ grade: 5, label: "5" },
];

export function ScoreButtons({ disabled, onScore }: ScoreButtonsProps) {
return (

<div className="grid grid-cols-3 gap-3 md:grid-cols-6">
{scoreLabels.map(({ grade, label }) => (
<Button
key={grade}
type="button"
variant="outline"
disabled={disabled}
onClick={() => onScore(grade)}
aria-label={`Ocena ${label}`} >
{label}
</Button>
))}
</div>
);
}

================================================
FILE: src/components/learning/SummaryModal.tsx
================================================
import { Button } from "@/components/ui/button";
import type { SessionStats } from "@/types";

interface SummaryModalProps {
open: boolean;
stats: SessionStats;
onRestart: () => void;
onDone: () => void;
}

export function SummaryModal({ open, stats, onRestart, onDone }: SummaryModalProps) {
if (!open) {
return null;
}

return (

<div className="fixed inset-0 z-50 flex items-center justify-center bg-black/40 p-4 backdrop-blur-sm">
<div className="w-full max-w-md rounded-2xl border bg-card p-6 shadow-xl">
<div className="space-y-1">
<p className="text-sm uppercase tracking-wide text-muted-foreground">Sesja zakończona</p>
<h2 className="text-2xl font-semibold text-foreground">Świetna robota!</h2>
<p className="text-sm text-muted-foreground">
Poniżej znajdziesz podsumowanie ocen dla tej sesji nauki. Możesz wrócić do listy fiszek lub rozpocząć
kolejną sesję.
</p>
</div>

        <div className="mt-6 grid grid-cols-2 gap-4 rounded-xl border bg-muted/40 p-4 text-center">
          <div>
            <p className="text-xs uppercase tracking-wide text-muted-foreground">Średnia ocena</p>
            <p className="text-3xl font-bold text-foreground">{stats.avgGrade.toFixed(2)}</p>
          </div>
          <div>
            <p className="text-xs uppercase tracking-wide text-muted-foreground">Ocenionych fiszek</p>
            <p className="text-3xl font-bold text-foreground">{stats.total}</p>
          </div>
        </div>

        <div className="mt-6 flex flex-col gap-3 sm:flex-row sm:justify-end">
          <Button variant="outline" onClick={onDone}>
            Zakończ
          </Button>
          <Button onClick={onRestart}>Nowa sesja</Button>
        </div>
      </div>
    </div>

);
}

================================================
FILE: src/components/navigation/SiteNavigation.astro
================================================

---

import { Home, Play, Sparkles, User } from "lucide-react";
import type { LucideIcon } from "lucide-react";

type IconName = "home" | "play" | "ai" | "user";
type UserInfo = { id: string; email: string | null } | null;

interface NavItem {
label: string;
mobileLabel?: string;
href: string;
icon: IconName;
}

interface Props {
currentPath: string;
user?: UserInfo;
}

const navItems: NavItem[] = [
{ label: "Moje fiszki", mobileLabel: "Fiszki", href: "/", icon: "home" },
{ label: "Sesja nauki", mobileLabel: "Nauka", href: "/learn", icon: "play" },
{ label: "Generuj", mobileLabel: "AI", href: "/generate", icon: "ai" },
{ label: "Konto", mobileLabel: "Konto", href: "/account", icon: "user" },
];

const normalizedPath = (path: string) => {
if (!path) return "/";
if (path !== "/" && path.endsWith("/")) return path.slice(0, -1);
return path;
};

const props = Astro.props as Props;
const currentPath = normalizedPath(props.currentPath ?? Astro.url.pathname);
const user = props.user ?? null;
const isAuthenticated = Boolean(user);
const userEmail = user?.email ?? "Brak e-maila";
const isActive = (href: string) => normalizedPath(href) === currentPath;
const navLabel = "Główna nawigacja";
const logoutScript = isAuthenticated
? `
(() => {
const logoutButtons = document.querySelectorAll("[data-nav-logout]");
if (!logoutButtons.length) return;

const showToast = (message, tone = "success") => {
window.dispatchEvent(
new CustomEvent("aiFlashcards:toast", {
detail: { message, tone },
})
);
};

const handleLogout = async (event) => {
event.preventDefault();
const target = event.currentTarget;
target.setAttribute("aria-busy", "true");
target.disabled = true;

    try {
      const response = await fetch("/api/auth/logout", { method: "POST" });
      if (!response.ok) {
        const payload = await response.json().catch(() => null);
        const message = payload?.error ?? "Nie udało się wylogować";
        throw new Error(message);
      }

      showToast("Wylogowano", "success");
      setTimeout(() => {
        window.location.href = "/auth/login";
      }, 800);
    } catch (error) {
      showToast(
        error instanceof Error ? error.message : "Nie udało się wylogować",
        "error"
      );
      console.error("Nie udało się wylogować", error);
      target.disabled = false;
      target.removeAttribute("aria-busy");
    }

};

logoutButtons.forEach((button) => {
button.addEventListener("click", handleLogout);
});
})();
`
: null;

const icons: Record<IconName, LucideIcon> = {
home: Home,
play: Play,
ai: Sparkles,
user: User,
};

---

<header
  class="sticky top-0 z-40 hidden border-b bg-background/80 backdrop-blur supports-[backdrop-filter]:bg-background/60 md:block"
>
  <div class="mx-auto flex max-w-6xl items-center justify-between px-4 py-3">
    <a class="flex items-center gap-2 text-base font-semibold text-foreground" href="/" aria-label="AI Flashcards">
      <span class="inline-flex size-9 items-center justify-center rounded-lg bg-primary/10 text-primary">AI</span>
      <span class="hidden sm:inline">AI Flashcards</span>
    </a>

    <nav class="flex items-center gap-1" aria-label={navLabel} role="navigation">
      {
        navItems.map((item) => (
          <a
            class={`rounded-md px-3 py-2 text-sm font-medium transition hover:text-foreground ${
              isActive(item.href)
                ? "text-foreground underline decoration-2 underline-offset-[10px]"
                : "text-muted-foreground"
            }`}
            href={item.href}
            aria-current={isActive(item.href) ? "page" : undefined}
          >
            {item.label}
          </a>
        ))
      }

      {
        isAuthenticated ? (
          <div class="ml-2 flex items-center gap-2 border-l pl-3 text-sm">
            <span class="text-xs text-muted-foreground" aria-label={`Zalogowano jako ${userEmail}`}>
              {userEmail}
            </span>
            <button
              type="button"
              class="rounded-md px-3 py-2 font-medium text-muted-foreground transition hover:text-destructive"
              data-nav-logout
              aria-label="Wyloguj"
            >
              Logout
            </button>
          </div>
        ) : null
      }
    </nav>

  </div>
</header>

<nav
  class="fixed inset-x-0 bottom-0 z-40 border-t bg-background/95 shadow-lg backdrop-blur supports-[backdrop-filter]:bg-background/60 md:hidden"
  aria-label={`${navLabel} (mobilna)`}
  role="navigation"
>
  <ul class={`grid ${isAuthenticated ? "grid-cols-5" : "grid-cols-4"}`}>
    {
      navItems.map((item) => (
        <li>
          <a
            class={`flex flex-col items-center gap-1 px-1.5 py-2 text-xs font-medium transition ${
              isActive(item.href) ? "text-primary" : "text-muted-foreground hover:text-foreground"
            }`}
            href={item.href}
            aria-current={isActive(item.href) ? "page" : undefined}
          >
            {(() => {
              const Icon = icons[item.icon];
              return <Icon className="size-5" aria-hidden="true" />;
            })()}
            <span>{item.mobileLabel ?? item.label}</span>
          </a>
        </li>
      ))
    }
    {
      isAuthenticated ? (
        <li>
          <div class="flex flex-col items-center gap-0.5 px-1.5 py-2 text-center">
            <span class="text-[10px] font-medium text-muted-foreground" aria-label={`Zalogowano jako ${userEmail}`}>
              {userEmail}
            </span>
            <button
              type="button"
              class="flex flex-col items-center gap-1 text-xs font-medium text-muted-foreground transition hover:text-destructive"
              data-nav-logout
              aria-label="Wyloguj"
            >
              <span aria-hidden="true">⎋</span>
              <span>Wyloguj</span>
            </button>
          </div>
        </li>
      ) : null
    }
  </ul>
</nav>

{logoutScript ? <script is:inline set:html={logoutScript} /> : null}

================================================
FILE: src/components/ui/button.tsx
================================================
import \* as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&\_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
{
variants: {
variant: {
default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
destructive:
"bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
outline:
"border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
link: "text-primary underline-offset-4 hover:underline",
},
size: {
default: "h-9 px-4 py-2 has-[>svg]:px-3",
sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
icon: "size-9",
},
},
defaultVariants: {
variant: "default",
size: "default",
},
}
);

function Button({
className,
variant,
size,
asChild = false,
...props
}: React.ComponentProps<"button"> &
VariantProps<typeof buttonVariants> & {
asChild?: boolean;
}) {
const Comp = asChild ? Slot : "button";

return <Comp data-slot="button" className={cn(buttonVariants({ variant, size, className }))} {...props} />;
}

export { Button, buttonVariants };

================================================
FILE: src/db/database.types.ts
================================================
[Binary file]

================================================
FILE: src/db/supabase.client.ts
================================================
import type { AstroCookies } from "astro";
import { createServerClient, type CookieOptionsWithName } from "@supabase/ssr";

import type { Database } from "./database.types.ts";

const cookieOptions: CookieOptionsWithName = {
path: "/",
secure: true,
httpOnly: true,
sameSite: "lax",
};

function parseCookieHeader(cookieHeader: string): { name: string; value: string }[] {
return cookieHeader.split(";").map((cookie) => {
const [name, ...rest] = cookie.trim().split("=");
return { name, value: rest.join("=") };
});
}

export const createSupabaseServerInstance = (context: { headers: Headers; cookies: AstroCookies }) => {
const supabaseUrl = import.meta.env.SUPABASE_URL;
const supabaseAnonKey = import.meta.env.SUPABASE_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
throw new Error("Missing SUPABASE_URL or SUPABASE_KEY environment variable");
}

return createServerClient<Database>(supabaseUrl, supabaseAnonKey, {
cookieOptions,
cookies: {
getAll() {
return parseCookieHeader(context.headers.get("Cookie") ?? "");
},
setAll(cookiesToSet) {
cookiesToSet.forEach(({ name, value, options }) => context.cookies.set(name, value, options));
},
},
});
};

export type SupabaseClient = ReturnType<typeof createSupabaseServerInstance>;

================================================
FILE: src/layouts/AuthLayout.astro
================================================

---

import "../styles/global.css";

interface Props {
title?: string;
heading?: string;
description?: string;
}

const { title = "AI Flashcards", heading, description } = Astro.props as Props;

const themeBootScript = `(function () {
  const STORAGE_KEY = "theme-mode";
  const isValidMode = (value) => value === "light" || value === "dark" || value === "system";
  let storedMode = null;
  try {
    storedMode = localStorage.getItem(STORAGE_KEY);
  } catch {
    storedMode = null;
  }
  const mode = isValidMode(storedMode) ? storedMode : "system";
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  const shouldUseDark = mode === "dark" || (mode === "system" && prefersDark);
  const root = document.documentElement;
  root.classList.toggle("dark", shouldUseDark);
  root.setAttribute("data-theme", shouldUseDark ? "dark" : "light");
  root.style.colorScheme = shouldUseDark ? "dark" : "light";
})();`;

---

<!doctype html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <script is:inline set:html={themeBootScript} />
  </head>
  <body class="bg-background text-foreground">
    <main class="flex min-h-screen flex-col items-center justify-center px-4 py-10">
      <div class="w-full max-w-5xl space-y-6">
        <header class="flex flex-col gap-2 text-center">
          <p class="text-sm uppercase tracking-[0.3em] text-muted-foreground">AI Flashcards</p>
          <h1 class="text-3xl font-semibold leading-tight text-foreground sm:text-4xl">
            {heading ?? title}
          </h1>
          <p class="text-sm text-muted-foreground sm:text-base">
            {description ?? "Aplikacja do nauki fiszek."}
          </p>
        </header>
        <section class="grid gap-6 justify-center"><slot /></section>
      </div>
    </main>
  </body>
</html>

================================================
FILE: src/layouts/Layout.astro
================================================

---

import "../styles/global.css";
import SiteNavigation from "../components/navigation/SiteNavigation.astro";

interface Props {
title?: string;
}

const props = Astro.props as Props;
const title = props.title ?? "AI Flashcards";
const currentPath = Astro.url.pathname;
const user = Astro.locals.user ?? null;
const themeBootScript = `(() => {
  const STORAGE_KEY = "theme-mode";
  const isValidMode = (value) => value === "light" || value === "dark" || value === "system";
  let storedMode = null;
  try {
    storedMode = localStorage.getItem(STORAGE_KEY);
  } catch {
    storedMode = null;
  }
  const mode = isValidMode(storedMode) ? storedMode : "system";
  const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
  const shouldUseDark = mode === "dark" || (mode === "system" && prefersDark);
  const root = document.documentElement;
  root.classList.toggle("dark", shouldUseDark);
  root.setAttribute("data-theme", shouldUseDark ? "dark" : "light");
  root.style.colorScheme = shouldUseDark ? "dark" : "light";
})();`;
const toastScript = `
(() => {
const container = document.getElementById("site-toast-root");
if (!container) return;

const classes = {
success: "border-emerald-200/80 bg-emerald-50 text-emerald-900",
error: "border-destructive/40 bg-destructive/10 text-destructive",
};

let currentToast = null;
let hideTimeout = 0;

const removeToast = () => {
if (currentToast && container.contains(currentToast)) {
container.removeChild(currentToast);
}
currentToast = null;
clearTimeout(hideTimeout);
};

const showToast = (message, tone = "success") => {
removeToast();
if (!message) {
return;
}

    const toast = document.createElement("div");
    toast.setAttribute("role", "status");
    toast.className =
      "pointer-events-auto flex items-center gap-3 rounded-lg border px-4 py-3 text-sm shadow-md backdrop-blur-sm " +
      (classes[tone] ?? classes.success);

    const content = document.createElement("span");
    content.textContent = message;

    const closeButton = document.createElement("button");
    closeButton.type = "button";
    closeButton.className = "text-sm font-medium text-foreground/80 transition hover:text-foreground";
    closeButton.setAttribute("aria-label", "Zamknij powiadomienie");
    closeButton.textContent = "✕";
    closeButton.addEventListener("click", removeToast);

    toast.appendChild(content);
    toast.appendChild(closeButton);
    container.appendChild(toast);
    currentToast = toast;
    hideTimeout = window.setTimeout(removeToast, 4000);

};

window.addEventListener("aiFlashcards:toast", (event) => {
const detail = event.detail ?? {};
showToast(detail.message ?? "", detail.tone ?? "success");
});
})();
`;

---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <script is:inline set:html={themeBootScript} />
  </head>
  <body class="bg-background text-foreground">
    <div class="flex min-h-screen flex-col">
      <SiteNavigation currentPath={currentPath} user={user} />
      <div class="flex-1 pb-16 md:pb-0">
        <slot />
      </div>
    </div>
    <div
      id="site-toast-root"
      aria-live="polite"
      class="pointer-events-none fixed inset-x-0 top-4 z-50 flex justify-center px-4 sm:top-6"
    >
    </div>
    <script is:inline set:html={toastScript} />
  </body>
</html>

<style>
  html,
  body {
    margin: 0;
    width: 100%;
    height: 100%;
  }
</style>

================================================
FILE: src/lib/utils.ts
================================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
return twMerge(clsx(inputs))
}

================================================
FILE: src/lib/api/flashcards.client.ts
================================================
import type {
BulkCreateFlashcardsCommand,
BulkCreateFlashcardsResponse,
CreateFlashcardCommand,
FlashcardCreateResponse,
FlashcardListQuery,
FlashcardUpdateResponse,
UpdateFlashcardCommand,
} from "../../types";
import {
DEFAULT_FLASHCARD_PAGE_SIZE,
type FlashcardListPage,
type FlashcardListQueryVM,
toFlashcardListPage,
toFlashcardViewModel,
} from "../view-models/flashcards";

async function parseJsonOrText<T>(response: Response): Promise<T> {
const contentType = response.headers.get("content-type") ?? "";
if (contentType.includes("application/json")) {
return (await response.json()) as T;
}
return (await response.text()) as unknown as T;
}

async function handleResponse<T>(response: Response): Promise<T> {
if (response.ok) {
if (response.status === 204) {
// No Content
return {} as T;
}
return parseJsonOrText<T>(response);
}

const errorPayload = await parseJsonOrText<unknown>(response);
const message =
typeof errorPayload === "string"
? errorPayload
: ((errorPayload as { message?: string })?.message ?? response.statusText);
throw new Error(message || "Request failed");
}

function buildQueryParams(query: FlashcardListQuery): string {
const params = new URLSearchParams();
if (query.page) params.set("page", String(query.page));
if (query.pageSize) params.set("pageSize", String(query.pageSize));
if (query.source) params.set("source", query.source);
if (query.generationId) params.set("generationId", query.generationId);
if (query.sort) params.set("sort", query.sort);
return params.toString();
}

export interface FetchFlashcardsListArgs extends FlashcardListQueryVM {
signal?: AbortSignal;
}

export async function fetchFlashcardsList({
page,
pageSize = DEFAULT_FLASHCARD_PAGE_SIZE,
source,
sort,
signal,
}: FetchFlashcardsListArgs): Promise<FlashcardListPage> {
const search = buildQueryParams({
page,
pageSize,
source,
sort,
});

const response = await fetch(`/api/flashcards?${search}`, { method: "GET", signal });
const data = await handleResponse<Parameters<typeof toFlashcardListPage>[0]>(response);
return toFlashcardListPage(data);
}

export interface CreateFlashcardArgs {
payload: CreateFlashcardCommand;
signal?: AbortSignal;
}

export async function createFlashcardClient({ payload, signal }: CreateFlashcardArgs) {
const response = await fetch("/api/flashcards", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(payload),
signal,
});
const data = await handleResponse<FlashcardCreateResponse>(response);
return toFlashcardViewModel({
...data,
generationId: data.generationId ?? null,
updatedAt: data.createdAt,
});
}

export interface UpdateFlashcardArgs {
id: string;
payload: UpdateFlashcardCommand;
signal?: AbortSignal;
}

export async function updateFlashcardClient({ id, payload, signal }: UpdateFlashcardArgs) {
const response = await fetch(`/api/flashcards/${id}`, {
method: "PATCH",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(payload),
signal,
});
const data = await handleResponse<FlashcardUpdateResponse>(response);
return toFlashcardViewModel(data);
}

export interface DeleteFlashcardArgs {
id: string;
signal?: AbortSignal;
}

export async function deleteFlashcardClient({ id, signal }: DeleteFlashcardArgs) {
const response = await fetch(`/api/flashcards/${id}`, { method: "DELETE", signal });
await handleResponse<unknown>(response);
return id;
}

export interface BulkCreateFlashcardsArgs {
payload: BulkCreateFlashcardsCommand;
signal?: AbortSignal;
}

export async function bulkCreateFlashcardsClient({ payload, signal }: BulkCreateFlashcardsArgs) {
const response = await fetch("/api/flashcards/bulk", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(payload),
signal,
});
return handleResponse<BulkCreateFlashcardsResponse>(response);
}

================================================
FILE: src/lib/api/generations.client.ts
================================================
import type {
CreateGenerationCommand,
GenerationCreateResponse,
GenerationCreateWithFlashcardsResponse,
} from "../../types";
import type { FlashcardProposal } from "@/components/generate/types";

async function parseJsonOrText<T>(response: Response): Promise<T> {
const contentType = response.headers.get("content-type") ?? "";
if (contentType.includes("application/json")) {
return (await response.json()) as T;
}
return (await response.text()) as unknown as T;
}

async function handleResponse<T>(response: Response): Promise<T> {
if (response.ok) {
return parseJsonOrText<T>(response);
}

const errorPayload = await parseJsonOrText<unknown>(response);
const message =
typeof errorPayload === "string"
? errorPayload
: ((errorPayload as { message?: string; error?: string })?.message ??
(errorPayload as { error?: string }).error ??
response.statusText);
throw new Error(message || "Request failed");
}

export interface CreateGenerationArgs {
payload: CreateGenerationCommand;
signal?: AbortSignal;
}

function toProposalId(index: number) {
return typeof crypto !== "undefined" && crypto.randomUUID ? crypto.randomUUID() : `proposal-${index}-${Date.now()}`;
}

export async function createGenerationClient({
payload,
signal,
}: CreateGenerationArgs): Promise<{ generation: GenerationCreateResponse; proposals: FlashcardProposal[] }> {
const response = await fetch("/api/generations", {
method: "POST",
headers: { "Content-Type": "application/json" },
body: JSON.stringify(payload),
signal,
});

const { generation, flashcards } = await handleResponse<GenerationCreateWithFlashcardsResponse>(response);

const proposals: FlashcardProposal[] = flashcards.map((item, index) => ({
id: toProposalId(index),
front: item.front,
back: item.back,
state: "pending",
}));

return { generation, proposals };
}

================================================
FILE: src/lib/hooks/useHotkeys.ts
================================================
import { useEffect } from "react";

import type { Grade } from "@/types";

export interface UseHotkeysOptions {
onFlip?: () => void;
onScore?: (grade: Grade) => void;
enabled?: boolean;
}

export function useHotkeys({ onFlip, onScore, enabled = true }: UseHotkeysOptions) {
useEffect(() => {
if (!enabled) {
return undefined;
}

    const handler = (event: KeyboardEvent) => {
      const key = event.key;

      if (key === " " || key === "Spacebar" || key === "Enter") {
        event.preventDefault();
        onFlip?.();
        return;
      }

      if (key === "ArrowLeft") {
        event.preventDefault();
        onFlip?.();
        return;
      }

      if (key === "ArrowRight") {
        event.preventDefault();
        onScore?.(5);
        return;
      }

      if (/^[0-5]$/.test(key)) {
        event.preventDefault();
        onScore?.(Number(key) as Grade);
      }
    };

    window.addEventListener("keydown", handler);
    return () => window.removeEventListener("keydown", handler);

}, [enabled, onFlip, onScore]);
}

================================================
FILE: src/lib/hooks/useLearningSession.ts
================================================
import { useCallback, useEffect, useMemo, useRef, useState } from "react";

import type {
Grade,
LearningCardVM,
LearningSessionCommand,
LearningSessionResponse,
LearningSessionVM,
SessionStats,
} from "@/types";

const initialSession: LearningSessionVM = {
cards: [],
currentIndex: 0,
finished: false,
};

function mapToViewModel(response: LearningSessionResponse): LearningSessionVM {
const cards: LearningCardVM[] = response.cards.map((card) => ({
...card,
flipped: false,
}));

return {
cards,
currentIndex: 0,
finished: cards.length === 0,
};
}

function calculateStats(cards: LearningCardVM[]): SessionStats {
const graded = cards.filter((card) => typeof card.grade === "number");
if (!graded.length) {
return { avgGrade: 0, total: 0 };
}
const sum = graded.reduce((acc, card) => acc + (card.grade ?? 0), 0);
return { avgGrade: Number((sum / graded.length).toFixed(2)), total: graded.length };
}

export interface UseLearningSessionResult {
session: LearningSessionVM;
currentCard: LearningCardVM | undefined;
stats: SessionStats;
loading: boolean;
error: string | null;
fetchSession: (payload?: LearningSessionCommand) => Promise<void>;
reset: () => void;
flip: () => void;
score: (grade: Grade) => void;
next: () => void;
}

export function useLearningSession(defaultPayload: LearningSessionCommand = { count: 10 }): UseLearningSessionResult {
const [session, setSession] = useState<LearningSessionVM>(initialSession);
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);
const abortRef = useRef<AbortController | null>(null);
const initialPayloadRef = useRef<LearningSessionCommand>(defaultPayload);

const fetchSession = useCallback(async (payload?: LearningSessionCommand) => {
abortRef.current?.abort();
const controller = new AbortController();
abortRef.current = controller;

    setLoading(true);
    setError(null);

    const requestPayload = payload ?? initialPayloadRef.current ?? {};

    try {
      const response = await fetch("/api/learning/session", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(requestPayload),
        signal: controller.signal,
      });

      if (!response.ok) {
        let message = "Nie udało się pobrać sesji nauki";
        try {
          const errorBody = (await response.json()) as { error?: string };
          message = errorBody.error ?? message;
        } catch {
          message = response.statusText || message;
        }
        throw new Error(message);
      }

      const data = (await response.json()) as LearningSessionResponse;
      setSession(mapToViewModel(data));
    } catch (err) {
      if (controller.signal.aborted) {
        return;
      }
      const message = err instanceof Error ? err.message : "Nie udało się pobrać sesji nauki";
      setError(message);
      setSession(initialSession);
    } finally {
      setLoading(false);
    }

}, []);

const flip = useCallback(() => {
setSession((prev) => {
if (prev.finished) {
return prev;
}
const card = prev.cards[prev.currentIndex];
if (!card || typeof card.grade === "number") {
return prev;
}
const cards = [...prev.cards];
cards[prev.currentIndex] = { ...card, flipped: !card.flipped };
return { ...prev, cards };
});
}, []);

const next = useCallback(() => {
setSession((prev) => {
const hasNext = prev.currentIndex + 1 < prev.cards.length;
if (!hasNext) {
return { ...prev, finished: true };
}
return { ...prev, currentIndex: prev.currentIndex + 1 };
});
}, []);

const score = useCallback((grade: Grade) => {
if (!Number.isFinite(grade) || grade < 0 || grade > 5) {
return;
}

    setSession((prev) => {
      if (prev.finished) {
        return prev;
      }

      const card = prev.cards[prev.currentIndex];
      if (!card || !card.flipped || typeof card.grade === "number") {
        return prev;
      }

      const cards = [...prev.cards];
      cards[prev.currentIndex] = { ...card, grade };

      const isLast = prev.currentIndex === prev.cards.length - 1;
      const nextIndex = isLast ? prev.currentIndex : prev.currentIndex + 1;

      return {
        cards,
        currentIndex: nextIndex,
        finished: isLast,
      };
    });

}, []);

const reset = useCallback(() => {
abortRef.current?.abort();
setSession(initialSession);
setError(null);
}, []);

const currentCard = useMemo(() => session.cards[session.currentIndex], [session.cards, session.currentIndex]);
const stats = useMemo(() => calculateStats(session.cards), [session.cards]);

useEffect(() => {
fetchSession().catch(() => {
/_ handled in state _/
});
return () => abortRef.current?.abort();
}, [fetchSession]);

return {
session,
currentCard,
stats,
loading,
error,
fetchSession,
reset,
flip,
score,
next,
};
}

================================================
FILE: src/lib/services/flashcards.ts
================================================
import { z } from "zod";

import type { SupabaseClient } from "../../db/supabase.client.ts";
import type {
BulkCreateFlashcardsResponse,
FlashcardCreateResponse,
FlashcardDetailResponse,
FlashcardListQuery,
FlashcardListResponse,
FlashcardUpdateResponse,
SourceEnum,
UpdateFlashcardCommand,
} from "../../types";

/\*\*

- Zod validation schema for POST /api/flashcards.
  \*/
  const sourceEnumValues: readonly [SourceEnum, SourceEnum, SourceEnum] = ["ai_generated", "ai_edited", "manual"];

/\*\*

- Zod validation schema for path param id on /api/flashcards/:id.
  \*/
  export const idParamSchema = z.object({
  id: z.string().uuid({ message: "id must be a valid UUID" }),
  });

export const createFlashcardSchema = z.object({
front: z
.string({
required_error: "front is required",
invalid_type_error: "front must be a string",
})
.min(1, "front must be between 1 and 200 characters")
.max(200, "front must be between 1 and 200 characters"),
back: z
.string({
required_error: "back is required",
invalid_type_error: "back must be a string",
})
.min(1, "back must be between 1 and 500 characters")
.max(500, "back must be between 1 and 500 characters"),
source: z.enum(sourceEnumValues, {
errorMap: () => ({ message: 'source must be one of "ai_generated", "ai_edited", "manual"' }),
}),
generationId: z
.string()
.uuid({ message: "generationId must be a valid UUID" })
.optional()
.nullable()
.transform((value) => value ?? null),
});

export type CreateFlashcardInput = z.infer<typeof createFlashcardSchema>;

/\*\*

- Zod validation schema for POST /api/flashcards/bulk.
  \*/
  export const bulkCreateFlashcardsSchema = z.object({
  generationId: z
  .string()
  .uuid({ message: "generationId must be a valid UUID" })
  .optional()
  .nullable()
  .transform((value) => value ?? null),
  flashcards: z
  .array(createFlashcardSchema.omit({ generationId: true }))
  .min(1, "flashcards must contain between 1 and 50 items")
  .max(50, "flashcards must contain between 1 and 50 items"),
  });

export type BulkCreateFlashcardsInput = z.infer<typeof bulkCreateFlashcardsSchema>;

/\*\*

- Zod validation schema for PATCH /api/flashcards/:id.
  \*/
  export const updateFlashcardSchema = z
  .object({
  front: z
  .string({
  invalid_type_error: "front must be a string",
  })
  .min(1, "front must be between 1 and 200 characters")
  .max(200, "front must be between 1 and 200 characters")
  .optional(),
  back: z
  .string({
  invalid_type_error: "back must be a string",
  })
  .min(1, "back must be between 1 and 500 characters")
  .max(500, "back must be between 1 and 500 characters")
  .optional(),
  source: z
  .enum(sourceEnumValues, {
  errorMap: () => ({ message: 'source must be one of "ai_generated", "ai_edited", "manual"' }),
  })
  .optional(),
  })
  .refine((data) => data.front !== undefined || data.back !== undefined || data.source !== undefined, {
  message: "At least one of front, back, or source must be provided",
  });

export type UpdateFlashcardInput = z.infer<typeof updateFlashcardSchema>;

/\*\*

- Zod validation schema for GET /api/flashcards.
  \*/
  export const listFlashcardsSchema = z.object({
  page: z.coerce
  .number({ invalid_type_error: "page must be a number" })
  .int("page must be an integer")
  .min(1, "page must be at least 1")
  .default(1),
  pageSize: z.coerce
  .number({ invalid_type_error: "pageSize must be a number" })
  .int("pageSize must be an integer")
  .min(1, "pageSize must be at least 1")
  .max(100, "pageSize must be at most 100")
  .default(24),
  source: z
  .enum(sourceEnumValues, {
  errorMap: () => ({ message: 'source must be one of "ai_generated", "ai_edited", "manual"' }),
  })
  .optional(),
  generationId: z.string().uuid({ message: "generationId must be a valid UUID" }).optional(),
  sort: z
  .enum(["created_at desc", "created_at asc"], {
  errorMap: () => ({ message: 'sort must be "created_at desc" or "created_at asc"' }),
  })
  .default("created_at desc"),
  });

export type ListFlashcardsInput = z.infer<typeof listFlashcardsSchema>;

export interface CreateFlashcardParams {
supabase: SupabaseClient;
payload: CreateFlashcardInput;
userId: string;
}

export interface CreateFlashcardResult {
flashcard: FlashcardCreateResponse;
}

export class NotFoundError extends Error {
status = 404;
constructor(message: string) {
super(message);
this.name = "NotFoundError";
}
}

/\*\*

- Create a single flashcard and optionally link it to an existing generation.
  \*/
  export async function createFlashcard({
  supabase,
  payload,
  userId,
  }: CreateFlashcardParams): Promise<CreateFlashcardResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const parsed = createFlashcardSchema.parse(payload);

if (parsed.generationId) {
const { data, error } = await supabase
.from("generations")
.select("id")
.eq("id", parsed.generationId)
.eq("user_id", userId)
.single();

    if (error?.code === "PGRST116") {
      throw new NotFoundError("Generation not found");
    }

    if (error) {
      throw new Error(`Failed to verify generation: ${error.message}`);
    }

    if (!data) {
      throw new NotFoundError("Generation not found");
    }

}

const { data: inserted, error: insertError } = await supabase
.from("flashcards")
.insert({
user_id: userId,
generation_id: parsed.generationId,
front: parsed.front,
back: parsed.back,
source: parsed.source,
})
.select("\*")
.single();

if (insertError) {
throw new Error(`Failed to insert flashcard: ${insertError.message}`);
}

if (!inserted) {
throw new Error("Flashcard insertion returned no data");
}

const flashcard: FlashcardCreateResponse = {
id: inserted.id,
front: inserted.front,
back: inserted.back,
source: inserted.source,
generationId: inserted.generation_id,
createdAt: inserted.created_at,
};

return { flashcard };
}

export interface BulkCreateFlashcardsParams {
supabase: SupabaseClient;
payload: BulkCreateFlashcardsInput;
userId: string;
}

export interface BulkCreateFlashcardsResult {
result: BulkCreateFlashcardsResponse;
}

/\*\*

- Insert multiple flashcards in a single batch and optionally link them to a generation.
  \*/
  export async function bulkCreateFlashcards({
  supabase,
  payload,
  userId,
  }: BulkCreateFlashcardsParams): Promise<BulkCreateFlashcardsResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const parsed = bulkCreateFlashcardsSchema.parse(payload);

if (parsed.generationId) {
const { data, error } = await supabase
.from("generations")
.select("id")
.eq("id", parsed.generationId)
.eq("user_id", userId)
.single();

    if (error?.code === "PGRST116") {
      throw new NotFoundError("Generation not found");
    }

    if (error) {
      throw new Error(`Failed to verify generation: ${error.message}`);
    }

    if (!data) {
      throw new NotFoundError("Generation not found");
    }

}

const records = parsed.flashcards.map((flashcard) => ({
user_id: userId,
generation_id: parsed.generationId,
front: flashcard.front,
back: flashcard.back,
source: flashcard.source,
}));

const { data: inserted, error: insertError } = await supabase.from("flashcards").insert(records).select("id");

if (insertError) {
throw new Error(`Failed to insert flashcards: ${insertError.message}`);
}

if (!inserted || inserted.length === 0) {
throw new Error("Flashcards insertion returned no data");
}

const result: BulkCreateFlashcardsResponse = {
created: inserted.length,
ids: inserted.map((row) => row.id),
};

return { result };
}

export interface ListFlashcardsParams {
supabase: SupabaseClient;
query: FlashcardListQuery;
userId: string;
}

export interface ListFlashcardsResult {
result: FlashcardListResponse;
}

/\*\*

- List flashcards for a user with optional filters and pagination.
  \*/
  export async function listFlashcards({ supabase, query, userId }: ListFlashcardsParams): Promise<ListFlashcardsResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const parsed = listFlashcardsSchema.parse(query);

const offset = (parsed.page - 1) \* parsed.pageSize;
const ascending = parsed.sort === "created_at asc";

let builder = supabase.from("flashcards").select("\*", { count: "exact" }).eq("user_id", userId);

if (parsed.source) {
builder = builder.eq("source", parsed.source);
}

const { data, error, count } = await builder
.order("created_at", { ascending })
.range(offset, offset + parsed.pageSize - 1);

if (error) {
throw new Error(`Failed to list flashcards: ${error.message}`);
}

const items =
data?.map((row) => ({
id: row.id,
front: row.front,
back: row.back,
source: row.source,
generationId: row.generation_id,
createdAt: row.created_at,
updatedAt: row.updated_at,
})) ?? [];

const result: FlashcardListResponse = {
items,
page: parsed.page,
pageSize: parsed.pageSize,
total: count ?? 0,
};

return { result };
}

export interface GetFlashcardByIdParams {
supabase: SupabaseClient;
id: string;
userId: string;
}

export interface GetFlashcardByIdResult {
flashcard: FlashcardDetailResponse;
}

/\*\*

- Fetch a single flashcard owned by the user.
  \*/
  export async function getFlashcardById({
  supabase,
  id,
  userId,
  }: GetFlashcardByIdParams): Promise<GetFlashcardByIdResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const { data, error } = await supabase.from("flashcards").select("\*").eq("id", id).eq("user_id", userId).single();

if (error?.code === "PGRST116") {
throw new NotFoundError("Flashcard not found");
}

if (error) {
throw new Error(`Failed to fetch flashcard: ${error.message}`);
}

if (!data) {
throw new NotFoundError("Flashcard not found");
}

const flashcard: FlashcardDetailResponse = {
id: data.id,
front: data.front,
back: data.back,
source: data.source,
generationId: data.generation_id,
createdAt: data.created_at,
updatedAt: data.updated_at,
};

return { flashcard };
}

export interface UpdateFlashcardParams {
supabase: SupabaseClient;
id: string;
payload: UpdateFlashcardCommand;
userId: string;
}

export interface UpdateFlashcardResult {
flashcard: FlashcardUpdateResponse;
}

/\*\*

- Partially update a flashcard. If front/back change and previous source was ai_generated,
- the source is upgraded to ai_edited unless the client explicitly sets manual.
  \*/
  export async function updateFlashcard({
  supabase,
  id,
  payload,
  userId,
  }: UpdateFlashcardParams): Promise<UpdateFlashcardResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const parsed = updateFlashcardSchema.parse(payload);

const { data: existing, error: fetchError } = await supabase
.from("flashcards")
.select("\*")
.eq("id", id)
.eq("user_id", userId)
.single();

if (fetchError?.code === "PGRST116") {
throw new NotFoundError("Flashcard not found");
}

if (fetchError) {
throw new Error(`Failed to fetch flashcard: ${fetchError.message}`);
}

if (!existing) {
throw new NotFoundError("Flashcard not found");
}

const frontChanged = parsed.front !== undefined && parsed.front !== existing.front;
const backChanged = parsed.back !== undefined && parsed.back !== existing.back;

let nextSource: SourceEnum = existing.source;
if (parsed.source) {
nextSource = parsed.source;
} else if ((frontChanged || backChanged) && existing.source === "ai_generated") {
nextSource = "ai_edited";
}

const updates: Record<string, unknown> = {};
if (parsed.front !== undefined) updates.front = parsed.front;
if (parsed.back !== undefined) updates.back = parsed.back;
if (nextSource !== existing.source || parsed.source !== undefined) {
updates.source = nextSource;
}

const { data, error } = await supabase
.from("flashcards")
.update(updates)
.eq("id", id)
.eq("user_id", userId)
.select("\*")
.single();

if (error?.code === "PGRST116") {
throw new NotFoundError("Flashcard not found");
}

if (error) {
throw new Error(`Failed to update flashcard: ${error.message}`);
}

if (!data) {
throw new Error("Flashcard update returned no data");
}

const flashcard: FlashcardUpdateResponse = {
id: data.id,
front: data.front,
back: data.back,
source: data.source,
generationId: data.generation_id,
createdAt: data.created_at,
updatedAt: data.updated_at,
};

return { flashcard };
}

export interface DeleteFlashcardParams {
supabase: SupabaseClient;
id: string;
userId: string;
}

export interface DeleteFlashcardResult {
id: string;
}

/\*\*

- Delete a single flashcard owned by the user.
  \*/
  export async function deleteFlashcard({ supabase, id, userId }: DeleteFlashcardParams): Promise<DeleteFlashcardResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const { data, error } = await supabase
.from("flashcards")
.delete()
.eq("id", id)
.eq("user_id", userId)
.select("id")
.single();

if (error?.code === "PGRST116") {
throw new NotFoundError("Flashcard not found");
}

if (error) {
throw new Error(`Failed to delete flashcard: ${error.message}`);
}

if (!data?.id) {
throw new NotFoundError("Flashcard not found");
}

return { id: data.id };
}

================================================
FILE: src/lib/services/generations.ts
================================================
import { createHash, randomUUID } from "node:crypto";
import { z } from "zod";

import type { SupabaseClient } from "../../db/supabase.client.ts";
import { openRouter } from "./openrouter";
import type {
CreateGenerationCommand,
GeneratedFlashcard,
GenerationCreateResponse,
GenerationCreateWithFlashcardsResponse,
JsonSchemaFormat,
ResponseFormat,
} from "../../types";

/\*\*

- Zod validation schema for POST /api/generations.
  \*/
  export const createGenerationSchema = z.object({
  text: z
  .string({
  required_error: "text is required",
  invalid_type_error: "text must be a string",
  })
  .min(1000, "text must be between 1000 and 10000 characters")
  .max(10000, "text must be between 1000 and 10000 characters"),
  model: z.literal("gpt-4o-mini", {
  errorMap: () => ({ message: 'model must be "gpt-4o-mini"' }),
  }),
  });

export type CreateGenerationInput = CreateGenerationCommand;

export interface CreateGenerationParams extends CreateGenerationInput {
supabase: SupabaseClient;
userId: string;
}

export type CreateGenerationResult = GenerationCreateWithFlashcardsResponse;

/\*\*

- Create a generation using LLM to propose flashcards.
  \*/
  export async function createGeneration({
  supabase,
  userId,
  text,
  model,
  }: CreateGenerationParams): Promise<CreateGenerationResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const validated = createGenerationSchema.parse({ text, model });

const inputLength = validated.text.length;
const hash = createHash("sha256").update(validated.text, "utf8").digest("hex");

const responseFormat = buildFlashcardsResponseFormat();
const { flashcards, generationTimeMs } = await generateFlashcardsWithLlm({
text: validated.text,
model: validated.model,
responseFormat,
});

const { data, error } = await supabase
.from("generations")
.insert({
user_id: userId,
hash,
input_length: inputLength,
generation_time_ms: generationTimeMs,
generated_count: flashcards.length,
accepted_count: 0,
accepted_edited_count: 0,
model_name: validated.model,
})
.select("\*")
.single();

if (error || !data) {
throw new Error(`Failed to insert generation: ${error?.message ?? "unknown error"}`);
}

const generation: GenerationCreateResponse = {
id: data.id ?? randomUUID(),
hash: data.hash,
inputLength: data.input_length,
generatedCount: data.generated_count,
createdAt: data.created_at ?? new Date().toISOString(),
};

return { generation, flashcards };
}

function buildFlashcardsResponseFormat(): ResponseFormat {
const flashcardSchema: JsonSchemaFormat["json_schema"]["schema"] = {
type: "object",
properties: {
flashcards: {
type: "array",
minItems: 3,
maxItems: 20,
items: {
type: "object",
properties: {
front: { type: "string", minLength: 1, maxLength: 200 },
back: { type: "string", minLength: 1, maxLength: 500 },
},
required: ["front", "back"],
additionalProperties: false,
},
},
},
required: ["flashcards"],
additionalProperties: false,
};

const responseFormat: JsonSchemaFormat = {
type: "json_schema",
json_schema: {
name: "flashcards_response",
strict: true,
schema: flashcardSchema,
description: "Flashcards extracted from the provided text",
},
};

return responseFormat;
}

async function generateFlashcardsWithLlm({
text,
model,
responseFormat,
}: {
text: string;
model: string;
responseFormat: ResponseFormat;
}): Promise<{ flashcards: GeneratedFlashcard[]; generationTimeMs: number }> {
const start = Date.now();

const systemPrompt =
"You are a flashcard generator. Create concise Q&A flashcards in the provided JSON schema. " +
"Use the source text only. Prefer clear, short questions and answers.";
const userPrompt =
"Extract 8-12 high-quality flashcards from the text below. " +
"Return only the JSON; do not include explanations.\n\n" +
"--- TEXT START ---\n" +
text +
"\n--- TEXT END ---";

const { json } = await openRouter.sendChat(
[openRouter.buildMessage("system", systemPrompt), openRouter.buildMessage("user", userPrompt)],
{
model,
temperature: 0.3,
max_tokens: 1200,
response_format: responseFormat,
}
);

if (!json || typeof json !== "object" || !("flashcards" in json)) {
throw new Error("LLM response missing flashcards field");
}

const rawFlashcards = Array.isArray((json as { flashcards: unknown }).flashcards)
? ((json as { flashcards: unknown[] }).flashcards ?? [])
: [];

const flashcards = rawFlashcards.reduce<GeneratedFlashcard[]>((acc, item) => {
if (
!item ||
typeof item !== "object" ||
typeof (item as { front?: unknown }).front !== "string" ||
typeof (item as { back?: unknown }).back !== "string"
) {
return acc;
}
const front = (item as { front: string }).front.trim();
const back = (item as { back: string }).back.trim();
if (!front || !back) {
return acc;
}
acc.push({
front,
back,
source: "ai_generated",
});
return acc;
}, []);

if (flashcards.length === 0) {
throw new Error("LLM returned no valid flashcards");
}

const generationTimeMs = Math.max(1, Date.now() - start);
return { flashcards, generationTimeMs };
}

================================================
FILE: src/lib/services/learning.ts
================================================
import { z } from "zod";

import type { SupabaseClient } from "../../db/supabase.client.ts";
import type { LearningSessionResponse, SourceEnum } from "../../types";

const sourceEnumValues: readonly [SourceEnum, SourceEnum, SourceEnum] = ["ai_generated", "ai_edited", "manual"];

export const learningSessionSchema = z.object({
count: z.coerce
.number({ invalid_type_error: "count must be a number" })
.int("count must be an integer")
.min(1, "count must be at least 1")
.max(100, "count must be at most 100")
.default(10),
source: z
.enum(sourceEnumValues, {
errorMap: () => ({ message: 'source must be one of "ai_generated", "ai_edited", "manual"' }),
})
.optional(),
});

export type LearningSessionInput = z.infer<typeof learningSessionSchema>;

export interface GetLearningSessionParams {
supabase: SupabaseClient;
payload: LearningSessionInput;
userId: string;
}

export interface GetLearningSessionResult {
result: LearningSessionResponse;
}

/\*\*

- Prepare a learning session by selecting flashcards for the user
- with optional filters and limit.
  \*/
  export async function getLearningSession({
  supabase,
  payload,
  userId,
  }: GetLearningSessionParams): Promise<GetLearningSessionResult> {
  if (!supabase) {
  throw new Error("Supabase client is required");
  }
  if (!userId) {
  throw new Error("User ID is required");
  }

const parsed = learningSessionSchema.parse(payload);

let builder = supabase.from("flashcards").select("id, front, back").eq("user_id", userId);

if (parsed.source) {
builder = builder.eq("source", parsed.source);
}

const { data, error } = await builder.order("created_at", { ascending: false }).limit(parsed.count);

if (error) {
throw new Error(`Failed to fetch learning session cards: ${error.message}`);
}

const cards =
data?.map((row) => ({
id: row.id,
front: row.front,
back: row.back,
})) ?? [];

return { result: { cards } };
}

================================================
FILE: src/lib/services/openrouter.ts
================================================
import Ajv from "ajv";
import axios, { type AxiosInstance } from "axios";
import pLimit from "p-limit";

import type {
JsonSchemaFormat,
OpenRouterConfig,
OpenRouterMessage,
OpenRouterReply,
ParsedReply,
ResponseFormat,
SendChatOptions,
} from "../../types";

const DEFAULT_TIMEOUT_MS = 30_000;
const DEFAULT_MAX_RETRIES = 2;
const DEFAULT_RATE_LIMIT_QPS = 1;
const DEFAULT_MODEL = "openai/gpt-4o-mini";

export class OpenRouterService {
private readonly axios: AxiosInstance;
private readonly ajv: Ajv;
private readonly rateLimiter = pLimit(1);
private lastRequestAt = 0;

constructor(private readonly config: OpenRouterConfig) {
this.axios = axios.create({
baseURL: config.baseUrl,
headers: {
Authorization: `Bearer ${config.apiKey}`,
"Content-Type": "application/json",
},
timeout: config.timeoutMs,
});

    this.ajv = new Ajv({ allErrors: true, strict: false });

}

setDefaultModel(model: string): void {
this.config.defaultModel = model;
}

buildMessage(role: OpenRouterMessage["role"], content: string): OpenRouterMessage {
return { role, content };
}

async sendChat(messages: OpenRouterMessage[], opts: SendChatOptions = {}): Promise<ParsedReply> {
if (!Array.isArray(messages) || messages.length === 0) {
throw new Error("messages must contain at least one item");
}

    await this.ensureRateLimit();

    const payload = {
      model: opts.model ?? this.config.defaultModel,
      messages,
      response_format: opts.response_format,
      temperature: opts.temperature,
      max_tokens: opts.max_tokens,
    };

    return this.withRetry(async () => {
      const { data } = await this.axios.post<OpenRouterReply>("/chat/completions", payload, {
        signal: opts.abortSignal,
      });
      return this.parseResponse(data, opts.response_format);
    });

}

private async withRetry<T>(fn: () => Promise<T>, attempt = 0): Promise<T> {
try {
return await fn();
} catch (error) {
const shouldRetry = this.shouldRetry(error) && attempt < this.config.maxRetries;
if (!shouldRetry) {
throw this.handleError(error);
}

      const delayMs = Math.pow(2, attempt) * 500;
      await this.sleep(delayMs);
      return this.withRetry(fn, attempt + 1);
    }

}

private shouldRetry(error: unknown): boolean {
if (!axios.isAxiosError(error)) {
return false;
}

    const status = error.response?.status;
    if (status && [401, 403, 404].includes(status)) {
      return false;
    }

    if (status && (status === 429 || status >= 500)) {
      return true;
    }

    return error.code === "ECONNABORTED" || error.message.toLowerCase().includes("timeout");

}

private ensureRateLimit(): Promise<void> {
const minInterval = 1000 / Math.max(1, this.config.rateLimitQPS);

    return this.rateLimiter(async () => {
      const now = Date.now();
      const waitMs = Math.max(0, this.lastRequestAt + minInterval - now);
      if (waitMs > 0) {
        await this.sleep(waitMs);
      }
      this.lastRequestAt = Date.now();
    });

}

private parseResponse(resp: OpenRouterReply, responseFormat?: ResponseFormat): ParsedReply {
if (!resp || !Array.isArray(resp.choices) || resp.choices.length === 0) {
throw new Error("OpenRouter response is missing choices");
}

    const choice = resp.choices[0];
    if (!choice?.message?.content) {
      throw new Error("OpenRouter response is missing message content");
    }

    const content = choice.message.content;
    let parsedJson: unknown;

    if (responseFormat?.type === "json_schema") {
      parsedJson = this.parseAndValidateJson(content, responseFormat);
    }

    return {
      raw: resp,
      message: choice.message,
      content,
      json: parsedJson,
    };

}

private parseAndValidateJson(content: string, format: JsonSchemaFormat): unknown {
let parsed: unknown;

    try {
      parsed = JSON.parse(content);
    } catch (error) {
      throw new Error(`Failed to parse JSON response: ${(error as Error).message}`);
    }

    const valid = this.ajv.validate(format.json_schema.schema, parsed);
    if (!valid) {
      const details = this.ajv.errorsText(this.ajv.errors, { separator: "; " });
      throw new Error(`Response validation failed: ${details}`);
    }

    return parsed;

}

private handleError(error: unknown): Error {
if (!axios.isAxiosError(error)) {
return error instanceof Error ? error : new Error("Unknown error");
}

    const status = error.response?.status;

    if (status === 401) {
      return new Error("Unauthorized: check OpenRouter API key");
    }

    if (status === 429) {
      const retryAfter = error.response?.headers?.["retry-after"];
      return new Error(`Rate limited by OpenRouter${retryAfter ? `, retry after ${retryAfter}s` : ""}`);
    }

    if (status && status >= 500) {
      return new Error(`OpenRouter server error (${status})`);
    }

    if (error.code === "ECONNABORTED") {
      return new Error("Request to OpenRouter timed out");
    }

    return new Error(error.message ?? "OpenRouter request failed");

}

private sleep(ms: number): Promise<void> {
return new Promise((resolve) => setTimeout(resolve, ms));
}
}

const apiKey = import.meta.env.OPENROUTER_API_KEY;

if (!apiKey) {
throw new Error("Missing OPENROUTER_API_KEY environment variable");
}

const baseUrl = import.meta.env.OPENROUTER_BASE_URL ?? "https://openrouter.ai/api/v1";

export const openRouter = new OpenRouterService({
apiKey,
baseUrl,
timeoutMs: DEFAULT_TIMEOUT_MS,
maxRetries: DEFAULT_MAX_RETRIES,
rateLimitQPS: DEFAULT_RATE_LIMIT_QPS,
defaultModel: DEFAULT_MODEL,
});

================================================
FILE: src/lib/validation/authSchemas.ts
================================================
import { z } from "zod";

const PASSWORD_MIN_LENGTH = 8;
const PASSWORD_MAX_LENGTH = 128;

const LENGTH_MESSAGE = "Co najmniej 8 znaków";
const UPPERCASE_MESSAGE = "Przynajmniej jedna wielka litera";
const LOWERCASE_MESSAGE = "Przynajmniej jedna mała litera";
const DIGIT_MESSAGE = "Przynajmniej jedna cyfra";
const SPECIAL_CHAR_MESSAGE = "Przynajmniej jeden znak specjalny";

export const passwordRequirements = [
{
id: "length",
label: LENGTH_MESSAGE,
test: (value: string) => value.length >= PASSWORD_MIN_LENGTH,
},
{
id: "uppercase",
label: UPPERCASE_MESSAGE,
test: (value: string) => /[A-Z]/.test(value),
},
{
id: "lowercase",
label: LOWERCASE_MESSAGE,
test: (value: string) => /[a-z]/.test(value),
},
{
id: "digit",
label: DIGIT_MESSAGE,
test: (value: string) => /\d/.test(value),
},
{
id: "special",
label: SPECIAL_CHAR_MESSAGE,
test: (value: string) => /[^A-Za-z0-9]/.test(value),
},
] as const;

const trimmedEmail = z.string().trim().email("Podaj prawidłowy adres email");

const strongPassword = z
.string()
.min(PASSWORD_MIN_LENGTH, LENGTH_MESSAGE)
.max(PASSWORD_MAX_LENGTH, `Hasło może mieć maksymalnie ${PASSWORD_MAX_LENGTH} znaków`)
.refine(passwordRequirements[1].test, { message: UPPERCASE_MESSAGE })
.refine(passwordRequirements[2].test, { message: LOWERCASE_MESSAGE })
.refine(passwordRequirements[3].test, { message: DIGIT_MESSAGE })
.refine(passwordRequirements[4].test, { message: SPECIAL_CHAR_MESSAGE });

export const loginSchema = z.object({
email: trimmedEmail,
password: z.string().min(1, "Podaj hasło"),
});

export const registerSchema = z
.object({
email: trimmedEmail,
password: strongPassword,
confirmPassword: z.string().min(1, "Potwierdź hasło"),
})
.superRefine(({ password, confirmPassword }, ctx) => {
if (confirmPassword !== password) {
ctx.addIssue({
code: "custom",
path: ["confirmPassword"],
message: "Hasła muszą się zgadzać",
});
}
});

export const resetRequestSchema = z.object({
email: trimmedEmail,
});

export const resetConfirmSchema = z
.object({
password: strongPassword,
confirmPassword: z.string().min(1, "Potwierdź hasło"),
})
.superRefine(({ password, confirmPassword }, ctx) => {
if (confirmPassword !== password) {
ctx.addIssue({
code: "custom",
path: ["confirmPassword"],
message: "Hasła muszą się zgadzać",
});
}
});

================================================
FILE: src/lib/view-models/flashcards.ts
================================================
import type { FlashcardDTO, FlashcardListResponse, SourceEnum } from "../../types";

export type SortOption = "created_at desc" | "created_at asc";

export interface FlashcardViewModel {
id: string;
front: string;
back: string;
source: SourceEnum;
generationId: string | null;
createdAt: string;
updatedAt: string;
createdLabel: string;
}

export interface FlashcardListQueryVM {
page: number;
pageSize: number;
source?: SourceEnum;
sort: SortOption;
}

export interface FlashcardListPage {
items: FlashcardViewModel[];
page: number;
pageSize: number;
total: number;
}

export const DEFAULT_FLASHCARD_PAGE_SIZE = 24;

const createdAtFormatter = new Intl.DateTimeFormat("pl-PL", {
year: "numeric",
month: "short",
day: "2-digit",
});

export function toFlashcardViewModel(dto: FlashcardDTO): FlashcardViewModel {
const createdAt = dto.createdAt ?? new Date().toISOString();
const updatedAt = dto.updatedAt ?? createdAt;
const createdAtDate = dto.createdAt ? new Date(dto.createdAt) : new Date();

return {
id: dto.id,
front: dto.front,
back: dto.back,
source: dto.source,
generationId: dto.generationId,
createdAt,
updatedAt,
createdLabel: createdAtFormatter.format(createdAtDate),
};
}

export function toFlashcardListPage(response: FlashcardListResponse): FlashcardListPage {
return {
items: response.items.map(toFlashcardViewModel),
page: response.page,
pageSize: response.pageSize,
total: response.total,
};
}

================================================
FILE: src/middleware/index.ts
================================================
import { defineMiddleware } from "astro:middleware";

import { createSupabaseServerInstance } from "../db/supabase.client.ts";

const PUBLIC_PATHS = ["/auth/login", "/auth/register", "/auth/reset", "/auth/reset/confirm", "/api/auth/login"];
const PUBLIC_PREFIXES = ["/auth/", "/api/auth/"];
const ASSET_PREFIXES = ["/_astro", "/_image"];
const ASSET_EXTENSIONS = /\.(css|js|ico|png|jpg|jpeg|svg|webp|gif|txt|map)$/;

function isPublicPath(pathname: string) {
return PUBLIC_PATHS.includes(pathname) || PUBLIC_PREFIXES.some((prefix) => pathname.startsWith(prefix));
}

function isAssetRequest(pathname: string) {
return ASSET_PREFIXES.some((prefix) => pathname.startsWith(prefix)) || ASSET_EXTENSIONS.test(pathname);
}

export const onRequest = defineMiddleware(async ({ locals, cookies, url, request, redirect }, next) => {
if (isAssetRequest(url.pathname)) {
return next();
}

const supabase = createSupabaseServerInstance({ cookies, headers: request.headers });
locals.supabase = supabase;

const {
data: { user },
} = await supabase.auth.getUser();

if (user) {
locals.user = {
id: user.id,
email: user.email ?? null,
};
}

if (url.pathname.startsWith("/api/auth/")) {
return next();
}

const isPublic = isPublicPath(url.pathname);

if (user && isPublic) {
return redirect("/");
}

if (user) {
return next();
}

if (!isPublic) {
return redirect("/auth/login");
}

return next();
});

================================================
FILE: src/pages/account.astro
================================================

---

import Layout from "../layouts/Layout.astro";
import AccountPage from "../components/account/AccountPage";

## const user = Astro.locals.user ?? null;

<Layout title="Twoje konto">
  <AccountPage client:load user={user} />
</Layout>

================================================
FILE: src/pages/generate.astro
================================================

---

import Layout from "../layouts/Layout.astro";
import GeneratePage from "../components/generate/GeneratePage";

---

<Layout title="Generuj fiszki">
  <GeneratePage client:load />
</Layout>

================================================
FILE: src/pages/index.astro
================================================

---

import Layout from "../layouts/Layout.astro";
import MyFlashcardsView from "../components/flashcards/MyFlashcardsView";

---

<Layout title="Moje fiszki">
  <MyFlashcardsView client:load />
</Layout>

================================================
FILE: src/pages/learn.astro
================================================

---

import Layout from "../layouts/Layout.astro";
import LearningSession from "../components/learning/LearningSession";

## export const prerender = false;

<Layout title="Sesja nauki">
  <LearningSession client:load />
</Layout>

================================================
FILE: src/pages/api/flashcards.ts
================================================
import type { APIRoute } from "astro";

import {
createFlashcard,
createFlashcardSchema,
listFlashcards,
listFlashcardsSchema,
NotFoundError,
} from "../../lib/services/flashcards.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };

const unauthorizedResponse = () =>
new Response(JSON.stringify({ error: "User not authenticated" }), {
status: 401,
headers: jsonHeaders,
});

export const POST: APIRoute = async ({ request, locals }) => {
if (!locals?.supabase) {
return new Response(JSON.stringify({ error: "Supabase client not available" }), {
status: 500,
headers: jsonHeaders,
});
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

let body: unknown;
try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: "Invalid JSON payload" }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = createFlashcardSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: "Validation error", details: parsed.error.flatten() }), {
status: 400,
headers: jsonHeaders,
});
}

try {
const { flashcard } = await createFlashcard({
supabase: locals.supabase,
payload: parsed.data,
userId,
});

    return new Response(JSON.stringify(flashcard), {
      status: 201,
      headers: jsonHeaders,
    });

} catch (error) {
if (error instanceof NotFoundError) {
return new Response(JSON.stringify({ error: error.message }), {
status: 404,
headers: jsonHeaders,
});
}

    // eslint-disable-next-line no-console
    console.error("createFlashcard failed", { error });
    return new Response(JSON.stringify({ error: "Internal Server Error" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });

}
};

export const GET: APIRoute = async ({ request, locals }) => {
if (!locals?.supabase) {
return new Response(JSON.stringify({ error: "Supabase client not available" }), {
status: 500,
headers: jsonHeaders,
});
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

const url = new URL(request.url);
const parsed = listFlashcardsSchema.safeParse({
page: url.searchParams.get("page") ?? undefined,
pageSize: url.searchParams.get("pageSize") ?? undefined,
source: url.searchParams.get("source") ?? undefined,
generationId: url.searchParams.get("generationId") ?? undefined,
sort: url.searchParams.get("sort") ?? undefined,
});

if (!parsed.success) {
return new Response(JSON.stringify({ error: "Validation error", details: parsed.error.flatten() }), {
status: 400,
headers: jsonHeaders,
});
}

try {
const { result } = await listFlashcards({
supabase: locals.supabase,
query: parsed.data,
userId,
});

    return new Response(JSON.stringify(result), {
      status: 200,
      headers: jsonHeaders,
    });

} catch (error) {
// eslint-disable-next-line no-console
console.error("listFlashcards failed", { error });
return new Response(JSON.stringify({ error: "Internal Server Error" }), {
status: 500,
headers: { "Content-Type": "application/json" },
});
}
};

================================================
FILE: src/pages/api/generations.ts
================================================
import type { APIRoute } from "astro";

import { createGeneration, createGenerationSchema } from "../../lib/services/generations.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };

const unauthorizedResponse = () =>
new Response(JSON.stringify({ error: "User not authenticated" }), {
status: 401,
headers: jsonHeaders,
});

export const POST: APIRoute = async ({ request, locals }) => {
if (!locals?.supabase) {
return new Response(JSON.stringify({ error: "Supabase client not available" }), {
status: 500,
headers: jsonHeaders,
});
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

let body: unknown;
try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: "Invalid JSON payload" }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = createGenerationSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: "Validation error", details: parsed.error.flatten() }), {
status: 400,
headers: jsonHeaders,
});
}

try {
const result = await createGeneration({
supabase: locals.supabase,
userId,
...parsed.data,
});

    return new Response(JSON.stringify(result), {
      status: 201,
      headers: jsonHeaders,
    });

} catch (error) {
const length = parsed.success ? parsed.data.text.length : undefined;

    // eslint-disable-next-line no-console
    console.error("createGeneration failed", { hash: "redacted", length, error });
    return new Response(JSON.stringify({ error: "Internal Server Error" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });

}
};

================================================
FILE: src/pages/api/auth/login.ts
================================================
import type { APIRoute } from "astro";

import { createSupabaseServerInstance } from "@/db/supabase.client.ts";
import { loginSchema } from "@/lib/validation/authSchemas.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };
const GENERIC_ERROR = "Nie udało się zalogować. Sprawdź dane i spróbuj ponownie.";

export const POST: APIRoute = async ({ request, cookies }) => {
let body: unknown;

try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: "Nieprawidłowe dane wejściowe." }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = loginSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: "Nieprawidłowe dane logowania." }), {
status: 400,
headers: jsonHeaders,
});
}

const supabase = createSupabaseServerInstance({ cookies, headers: request.headers });

const { data, error } = await supabase.auth.signInWithPassword(parsed.data);

if (error || !data?.user) {
return new Response(JSON.stringify({ error: GENERIC_ERROR }), {
status: 401,
headers: jsonHeaders,
});
}

return new Response(
JSON.stringify({
user: {
id: data.user.id,
email: data.user.email,
},
}),
{
status: 200,
headers: jsonHeaders,
}
);
};

================================================
FILE: src/pages/api/auth/logout.ts
================================================
import type { APIRoute } from "astro";

import { createSupabaseServerInstance } from "@/db/supabase.client.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };
const GENERIC_ERROR = "Nie udało się wylogować.";

export const POST: APIRoute = async ({ cookies, request }) => {
const supabase = createSupabaseServerInstance({ cookies, headers: request.headers });

try {
const { error } = await supabase.auth.signOut();

    if (error) {
      return new Response(JSON.stringify({ error: GENERIC_ERROR }), {
        status: 400,
        headers: jsonHeaders,
      });
    }

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: jsonHeaders,
    });

} catch (error) {
console.error("Logout failed", error);
return new Response(JSON.stringify({ error: GENERIC_ERROR }), {
status: 500,
headers: jsonHeaders,
});
}
};

================================================
FILE: src/pages/api/auth/register.ts
================================================
import type { APIRoute } from "astro";

import { createSupabaseServerInstance } from "@/db/supabase.client.ts";
import { registerSchema } from "@/lib/validation/authSchemas.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };
const GENERIC_ERROR = "Nie udało się zarejestrować. Spróbuj ponownie.";

export const POST: APIRoute = async ({ request, cookies }) => {
let body: unknown;

try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: "Nieprawidłowe dane wejściowe." }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = registerSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: "Nieprawidłowe dane rejestracji." }), {
status: 400,
headers: jsonHeaders,
});
}

const supabase = createSupabaseServerInstance({ cookies, headers: request.headers });
const origin = new URL(request.url).origin;

const { data, error } = await supabase.auth.signUp({
email: parsed.data.email,
password: parsed.data.password,
options: {
emailRedirectTo: `${origin}/auth/login`,
},
});

if (error) {
const isDuplicate = error.message?.toLowerCase().includes("registered");
const message = isDuplicate ? "Konto z tym adresem już istnieje." : GENERIC_ERROR;

    return new Response(JSON.stringify({ error: message }), {
      status: isDuplicate ? 409 : 400,
      headers: jsonHeaders,
    });

}

return new Response(
JSON.stringify({
user: data.user
? {
id: data.user.id,
email: data.user.email,
}
: null,
emailConfirmationRequired: true,
message: "Sprawdź skrzynkę i kliknij link, aby aktywować konto.",
}),
{
status: 201,
headers: jsonHeaders,
}
);
};

================================================
FILE: src/pages/api/auth/reset.ts
================================================
import type { APIRoute } from "astro";

import { createSupabaseServerInstance } from "@/db/supabase.client.ts";
import { resetRequestSchema } from "@/lib/validation/authSchemas.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };
const SUCCESS_MESSAGE = "Jeśli konto istnieje, wysłaliśmy link do resetu hasła.";
const INVALID_BODY_MESSAGE = "Nieprawidłowe dane wejściowe.";

export const POST: APIRoute = async ({ request, cookies }) => {
let body: unknown;

try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: INVALID_BODY_MESSAGE }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = resetRequestSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: INVALID_BODY_MESSAGE }), {
status: 400,
headers: jsonHeaders,
});
}

const supabase = createSupabaseServerInstance({ cookies, headers: request.headers });
const origin = new URL(request.url).origin;
const configuredBase = import.meta.env.PUBLIC_APP_URL?.replace(/\/$/, "");
const redirectBase = configuredBase || origin;

const { error } = await supabase.auth.resetPasswordForEmail(parsed.data.email, {
redirectTo: `${redirectBase}/auth/reset/confirm`,
});

if (error) {
console.error("Reset password email request failed", error);
}

return new Response(JSON.stringify({ message: SUCCESS_MESSAGE }), {
status: 200,
headers: jsonHeaders,
});
};

================================================
FILE: src/pages/api/auth/reset/confirm.ts
================================================
import type { APIRoute } from "astro";

import { createSupabaseServerInstance } from "@/db/supabase.client.ts";
import { resetConfirmSchema } from "@/lib/validation/authSchemas.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };
const GENERIC_ERROR = "Nie udało się zresetować hasła. Spróbuj ponownie.";
const TOKEN_ERROR = "Brak lub nieprawidłowy token resetu. Poproś o nowy link.";
const INVALID_BODY_MESSAGE = "Nieprawidłowe dane wejściowe.";

export const POST: APIRoute = async ({ request, cookies, url }) => {
let body: unknown;

try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: INVALID_BODY_MESSAGE }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = resetConfirmSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: INVALID_BODY_MESSAGE }), {
status: 400,
headers: jsonHeaders,
});
}

const rawBody = body as Record<string, unknown> | null;
const bodyToken = typeof rawBody?.token === "string" ? rawBody.token : null;
const queryToken = url.searchParams.get("access_token") ?? url.searchParams.get("code");
const token = bodyToken || queryToken;

if (!token) {
return new Response(JSON.stringify({ error: TOKEN_ERROR }), {
status: 400,
headers: jsonHeaders,
});
}

const supabase = createSupabaseServerInstance({ cookies, headers: request.headers });

const { error: exchangeError } = await supabase.auth.exchangeCodeForSession(token);
if (exchangeError) {
console.error("Failed to exchange reset token", exchangeError);
return new Response(JSON.stringify({ error: TOKEN_ERROR }), {
status: 400,
headers: jsonHeaders,
});
}

const { error: updateError } = await supabase.auth.updateUser({
password: parsed.data.password,
});

if (updateError) {
console.error("Failed to update password after reset", updateError);
return new Response(JSON.stringify({ error: GENERIC_ERROR }), {
status: 400,
headers: jsonHeaders,
});
}

await supabase.auth.signOut();

return new Response(
JSON.stringify({
success: true,
message: "Hasło zostało zaktualizowane. Zaloguj się ponownie.",
}),
{
status: 200,
headers: jsonHeaders,
}
);
};

================================================
FILE: src/pages/api/flashcards/[id].ts
================================================
import type { APIRoute } from "astro";

import {
deleteFlashcard,
getFlashcardById,
idParamSchema,
NotFoundError,
updateFlashcard,
updateFlashcardSchema,
} from "../../../lib/services/flashcards.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };

const supabaseMissingResponse = () =>
new Response(JSON.stringify({ error: "Supabase client not available" }), {
status: 500,
headers: jsonHeaders,
});

const unauthorizedResponse = () =>
new Response(JSON.stringify({ error: "User not authenticated" }), {
status: 401,
headers: jsonHeaders,
});

function validateIdParam(params: Record<string, string | undefined>) {
const parsed = idParamSchema.safeParse({ id: params.id });
if (!parsed.success) {
return {
error: new Response(JSON.stringify({ error: "Validation error", details: parsed.error.flatten() }), {
status: 400,
headers: jsonHeaders,
}),
};
}

return { id: parsed.data.id };
}

export const GET: APIRoute = async ({ params, locals }) => {
if (!locals?.supabase) {
return supabaseMissingResponse();
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

const { id, error: idError } = validateIdParam(params);
if (idError) {
return idError;
}

try {
const { flashcard } = await getFlashcardById({
supabase: locals.supabase,
id,
userId,
});

    return new Response(JSON.stringify(flashcard), {
      status: 200,
      headers: jsonHeaders,
    });

} catch (error) {
if (error instanceof NotFoundError) {
return new Response(JSON.stringify({ error: error.message }), {
status: 404,
headers: jsonHeaders,
});
}

    // eslint-disable-next-line no-console
    console.error("getFlashcardById failed", { id, error });
    return new Response(JSON.stringify({ error: "Internal Server Error" }), {
      status: 500,
      headers: jsonHeaders,
    });

}
};

export const PATCH: APIRoute = async ({ request, params, locals }) => {
if (!locals?.supabase) {
return supabaseMissingResponse();
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

const { id, error: idError } = validateIdParam(params);
if (idError) {
return idError;
}

let body: unknown;
try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: "Invalid JSON payload" }), {
status: 400,
headers: jsonHeaders,
});
}

const parsedBody = updateFlashcardSchema.safeParse(body);
if (!parsedBody.success) {
return new Response(JSON.stringify({ error: "Validation error", details: parsedBody.error.flatten() }), {
status: 400,
headers: jsonHeaders,
});
}

try {
const { flashcard } = await updateFlashcard({
supabase: locals.supabase,
id,
payload: parsedBody.data,
userId,
});

    return new Response(JSON.stringify(flashcard), {
      status: 200,
      headers: jsonHeaders,
    });

} catch (error) {
if (error instanceof NotFoundError) {
return new Response(JSON.stringify({ error: error.message }), {
status: 404,
headers: jsonHeaders,
});
}

    // eslint-disable-next-line no-console
    console.error("updateFlashcard failed", { id, error });
    return new Response(JSON.stringify({ error: "Internal Server Error" }), {
      status: 500,
      headers: jsonHeaders,
    });

}
};

export const DELETE: APIRoute = async ({ params, locals }) => {
if (!locals?.supabase) {
return supabaseMissingResponse();
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

const { id, error: idError } = validateIdParam(params);
if (idError) {
return idError;
}

try {
await deleteFlashcard({
supabase: locals.supabase,
id,
userId,
});

    return new Response(null, {
      status: 204,
      headers: jsonHeaders,
    });

} catch (error) {
if (error instanceof NotFoundError) {
return new Response(JSON.stringify({ error: error.message }), {
status: 404,
headers: jsonHeaders,
});
}

    // eslint-disable-next-line no-console
    console.error("deleteFlashcard failed", { id, error });
    return new Response(JSON.stringify({ error: "Internal Server Error" }), {
      status: 500,
      headers: jsonHeaders,
    });

}
};

================================================
FILE: src/pages/api/flashcards/bulk.ts
================================================
import type { APIRoute } from "astro";

import { bulkCreateFlashcards, bulkCreateFlashcardsSchema, NotFoundError } from "../../../lib/services/flashcards.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };

const unauthorizedResponse = () =>
new Response(JSON.stringify({ error: "User not authenticated" }), {
status: 401,
headers: jsonHeaders,
});

export const POST: APIRoute = async ({ request, locals }) => {
if (!locals?.supabase) {
return new Response(JSON.stringify({ error: "Supabase client not available" }), {
status: 500,
headers: jsonHeaders,
});
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

let body: unknown;
try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: "Invalid JSON payload" }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = bulkCreateFlashcardsSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: "Validation error", details: parsed.error.flatten() }), {
status: 400,
headers: jsonHeaders,
});
}

try {
const { result } = await bulkCreateFlashcards({
supabase: locals.supabase,
payload: parsed.data,
userId,
});

    return new Response(JSON.stringify(result), {
      status: 201,
      headers: jsonHeaders,
    });

} catch (error) {
if (error instanceof NotFoundError) {
return new Response(JSON.stringify({ error: error.message }), {
status: 404,
headers: { "Content-Type": "application/json" },
});
}

    // eslint-disable-next-line no-console
    console.error("bulkCreateFlashcards failed", { error });
    return new Response(JSON.stringify({ error: "Internal Server Error" }), {
      status: 500,
      headers: { "Content-Type": "application/json" },
    });

}
};

================================================
FILE: src/pages/api/learning/session.ts
================================================
import type { APIRoute } from "astro";

import { getLearningSession, learningSessionSchema } from "../../../lib/services/learning.ts";

export const prerender = false;

const jsonHeaders = { "Content-Type": "application/json" };

const unauthorizedResponse = () =>
new Response(JSON.stringify({ error: "User not authenticated" }), {
status: 401,
headers: jsonHeaders,
});

export const POST: APIRoute = async ({ request, locals }) => {
if (!locals?.supabase) {
return new Response(JSON.stringify({ error: "Supabase client not available" }), {
status: 500,
headers: jsonHeaders,
});
}

const userId = locals.user?.id;
if (!userId) {
return unauthorizedResponse();
}

let body: unknown;
try {
body = await request.json();
} catch {
return new Response(JSON.stringify({ error: "Invalid JSON payload" }), {
status: 400,
headers: jsonHeaders,
});
}

const parsed = learningSessionSchema.safeParse(body);
if (!parsed.success) {
return new Response(JSON.stringify({ error: "Validation error", details: parsed.error.flatten() }), {
status: 400,
headers: jsonHeaders,
});
}

try {
const { result } = await getLearningSession({
supabase: locals.supabase,
payload: parsed.data,
userId,
});

    return new Response(JSON.stringify(result), {
      status: 200,
      headers: jsonHeaders,
    });

} catch (error) {
// eslint-disable-next-line no-console
console.error("getLearningSession failed", { error });
return new Response(JSON.stringify({ error: "Internal Server Error" }), {
status: 500,
headers: jsonHeaders,
});
}
};

================================================
FILE: src/pages/auth/login.astro
================================================

---

import { createSupabaseServerInstance } from "@/db/supabase.client";
import AuthLayout from "@/layouts/AuthLayout.astro";
import { LoginForm } from "@/components/auth/LoginForm";

export const prerender = false;

const supabase = createSupabaseServerInstance({
headers: Astro.request.headers,
cookies: Astro.cookies,
});

const {
data: { user },
} = await supabase.auth.getUser();

if (user) {
return Astro.redirect("/");
}

---

<AuthLayout title="Logowanie" heading="Witaj ponownie">
  <LoginForm client:load />
</AuthLayout>

================================================
FILE: src/pages/auth/register.astro
================================================

---

import { createSupabaseServerInstance } from "@/db/supabase.client";
import AuthLayout from "@/layouts/AuthLayout.astro";
import { RegisterForm } from "@/components/auth/RegisterForm";

export const prerender = false;

const supabase = createSupabaseServerInstance({
headers: Astro.request.headers,
cookies: Astro.cookies,
});

const {
data: { user },
} = await supabase.auth.getUser();

if (user) {
return Astro.redirect("/");
}

---

<AuthLayout title="Rejestracja" heading="Zacznij tworzyć fiszki">
  <RegisterForm client:load />
</AuthLayout>

================================================
FILE: src/pages/auth/reset.astro
================================================

---

import AuthLayout from "@/layouts/AuthLayout.astro";
import { ResetRequestForm } from "@/components/auth/ResetRequestForm";

## export const prerender = false;

<AuthLayout title="Reset hasła" heading="Odzyskaj dostęp">
  <div class="grid gap-6 lg:grid-cols-[1fr_minmax(0,0.45fr)]">
    <ResetRequestForm client:load />
    <div
      class="hidden flex-col gap-3 rounded-2xl border border-border bg-card/80 p-5 text-sm text-muted-foreground shadow-lg shadow-black/5 dark:shadow-black/40 sm:flex"
    >
      <p class="text-xs uppercase tracking-[0.4em] text-muted-foreground">Co dalej?</p>
      <p>Wysłany link pozwoli ustawić nowe hasło.</p>
      <p class="text-xs">Po kliknięciu linku z emaila trafisz na stronę z formularzem potwierdzającym reset..</p>
    </div>
  </div>
</AuthLayout>

================================================
FILE: src/pages/auth/reset/confirm.astro
================================================

---

import AuthLayout from "@/layouts/AuthLayout.astro";
import { ResetConfirmForm } from "@/components/auth/ResetConfirmForm";

export const prerender = false;

## const token = Astro.url.searchParams.get("access_token") ?? Astro.url.searchParams.get("code");

<AuthLayout title="Potwierdź reset" heading="Nowe hasło">
  <div class="grid gap-6 lg:grid-cols-[1fr_minmax(0,0.45fr)]">
    <ResetConfirmForm client:load token={token} />
    <div
      class="hidden flex-col gap-3 rounded-2xl border border-border bg-card/80 p-5 text-sm text-muted-foreground shadow-lg shadow-black/5 dark:shadow-black/40 sm:flex"
    >
      <p class="text-xs uppercase tracking-[0.4em] text-muted-foreground">Bezpieczeństwo</p>
      <p>
        Hasło powinno być unikalne i nie używane wcześniej. Nasze wymagania zapewniają, że nowe hasło będzie odporne na
        podstawowe ataki słownikowe.
      </p>
      <p class="text-xs">Po zapisaniu hasła wrócimy do logowania, a sesja resetu zostanie automatycznie zamknięta.</p>
    </div>
  </div>
</AuthLayout>

================================================
FILE: src/styles/global.css
================================================
@import "tailwindcss";
@import "tw-animate-css";

@custom-variant dark (&:is(.dark \*));

:root {
--radius: 0.625rem;
--background: oklch(1 0 0);
--foreground: oklch(0.145 0 0);
--card: oklch(1 0 0);
--card-foreground: oklch(0.145 0 0);
--popover: oklch(1 0 0);
--popover-foreground: oklch(0.145 0 0);
--primary: oklch(0.205 0 0);
--primary-foreground: oklch(0.985 0 0);
--secondary: oklch(0.97 0 0);
--secondary-foreground: oklch(0.205 0 0);
--muted: oklch(0.97 0 0);
--muted-foreground: oklch(0.556 0 0);
--accent: oklch(0.97 0 0);
--accent-foreground: oklch(0.205 0 0);
--destructive: oklch(0.577 0.245 27.325);
--border: oklch(0.922 0 0);
--input: oklch(0.922 0 0);
--ring: oklch(0.708 0 0);
--chart-1: oklch(0.646 0.222 41.116);
--chart-2: oklch(0.6 0.118 184.704);
--chart-3: oklch(0.398 0.07 227.392);
--chart-4: oklch(0.828 0.189 84.429);
--chart-5: oklch(0.769 0.188 70.08);
--sidebar: oklch(0.985 0 0);
--sidebar-foreground: oklch(0.145 0 0);
--sidebar-primary: oklch(0.205 0 0);
--sidebar-primary-foreground: oklch(0.985 0 0);
--sidebar-accent: oklch(0.97 0 0);
--sidebar-accent-foreground: oklch(0.205 0 0);
--sidebar-border: oklch(0.922 0 0);
--sidebar-ring: oklch(0.708 0 0);
}

.dark {
--background: oklch(0.145 0 0);
--foreground: oklch(0.985 0 0);
--card: oklch(0.205 0 0);
--card-foreground: oklch(0.985 0 0);
--popover: oklch(0.205 0 0);
--popover-foreground: oklch(0.985 0 0);
--primary: oklch(0.922 0 0);
--primary-foreground: oklch(0.205 0 0);
--secondary: oklch(0.269 0 0);
--secondary-foreground: oklch(0.985 0 0);
--muted: oklch(0.269 0 0);
--muted-foreground: oklch(0.708 0 0);
--accent: oklch(0.269 0 0);
--accent-foreground: oklch(0.985 0 0);
--destructive: oklch(0.704 0.191 22.216);
--border: oklch(1 0 0 / 10%);
--input: oklch(1 0 0 / 15%);
--ring: oklch(0.556 0 0);
--chart-1: oklch(0.488 0.243 264.376);
--chart-2: oklch(0.696 0.17 162.48);
--chart-3: oklch(0.769 0.188 70.08);
--chart-4: oklch(0.627 0.265 303.9);
--chart-5: oklch(0.645 0.246 16.439);
--sidebar: oklch(0.205 0 0);
--sidebar-foreground: oklch(0.985 0 0);
--sidebar-primary: oklch(0.488 0.243 264.376);
--sidebar-primary-foreground: oklch(0.985 0 0);
--sidebar-accent: oklch(0.269 0 0);
--sidebar-accent-foreground: oklch(0.985 0 0);
--sidebar-border: oklch(1 0 0 / 10%);
--sidebar-ring: oklch(0.556 0 0);
}

@theme inline {
--radius-sm: calc(var(--radius) - 4px);
--radius-md: calc(var(--radius) - 2px);
--radius-lg: var(--radius);
--radius-xl: calc(var(--radius) + 4px);
--color-background: var(--background);
--color-foreground: var(--foreground);
--color-card: var(--card);
--color-card-foreground: var(--card-foreground);
--color-popover: var(--popover);
--color-popover-foreground: var(--popover-foreground);
--color-primary: var(--primary);
--color-primary-foreground: var(--primary-foreground);
--color-secondary: var(--secondary);
--color-secondary-foreground: var(--secondary-foreground);
--color-muted: var(--muted);
--color-muted-foreground: var(--muted-foreground);
--color-accent: var(--accent);
--color-accent-foreground: var(--accent-foreground);
--color-destructive: var(--destructive);
--color-border: var(--border);
--color-input: var(--input);
--color-ring: var(--ring);
--color-chart-1: var(--chart-1);
--color-chart-2: var(--chart-2);
--color-chart-3: var(--chart-3);
--color-chart-4: var(--chart-4);
--color-chart-5: var(--chart-5);
--color-sidebar: var(--sidebar);
--color-sidebar-foreground: var(--sidebar-foreground);
--color-sidebar-primary: var(--sidebar-primary);
--color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
--color-sidebar-accent: var(--sidebar-accent);
--color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
--color-sidebar-border: var(--sidebar-border);
--color-sidebar-ring: var(--sidebar-ring);
}

@layer base {

- {
  @apply border-border outline-ring/50;
  }
  body {
  @apply bg-background text-foreground;
  }
  }

</kod_projektu>

<stos_technologiczny>
Frontend - Astro z React dla komponentów interaktywnych:

- Astro 5 pozwala na tworzenie szybkich, wydajnych stron i aplikacji z minimalną ilością JavaScript
- React 19 zapewni interaktywność tam, gdzie jest potrzebna
- TypeScript 5 dla statycznego typowania kodu i lepszego wsparcia IDE
- Tailwind 4 pozwala na wygodne stylowanie aplikacji
- Shadcn/ui zapewnia bibliotekę dostępnych komponentów React, na których oprzemy UI

Backend - Supabase jako kompleksowe rozwiązanie backendowe:

- Zapewnia bazę danych PostgreSQL
- Zapewnia SDK w wielu językach, które posłużą jako Backend-as-a-Service
- Jest rozwiązaniem open source, które można hostować lokalnie lub na własnym serwerze
- Posiada wbudowaną autentykację użytkowników

AI - Komunikacja z modelami przez usługę Openrouter.ai:

- Dostęp do szerokiej gamy modeli (OpenAI, Anthropic, Google i wiele innych), które pozwolą nam znaleźć rozwiązanie zapewniające wysoką efektywność i niskie koszta
- Pozwala na ustawianie limitów finansowych na klucze API

CI/CD i Hosting:

- Github Actions do tworzenia pipeline’ów CI/CD
- DigitalOcean do hostowania aplikacji za pośrednictwem obrazu docker
  </stos_technologiczny>

Twoim zadaniem jest wygenerowanie szczegółowego planu testów, który będzie dostosowany do specyfiki projektu, uwzględniając wykorzystywane technologie, strukturę kodu oraz kluczowe elementy repozytorium. Plan testów powinien być napisany w języku polskim.

Przed stworzeniem planu testów, przeprowadź dogłębną analizę projektu wewnątrz bloku <analiza_projektu> w swoim bloku myślowym. W analizie uwzględnij:

1. Kluczowe komponenty projektu wynikające z analizy kodu:
   - Wymień i opisz główne komponenty projektu
2. Specyfikę stosu technologicznego i jego wpływ na strategię testowania:
   - Przeanalizuj każdy element stosu technologicznego i jego implikacje dla testowania
3. Priorytety testowe bazujące na strukturze repozytorium:
   - Zidentyfikuj i uszereguj obszary testowe według ważności
4. Potencjalne obszary ryzyka wymagające szczególnej uwagi w testach:
   - Wymień potencjalne ryzyka i uzasadnij, dlaczego wymagają specjalnej uwagi

Po zakończeniu analizy, stwórz plan testów wewnątrz bloku <plan_testów>. Plan powinien zawierać:

1. Wprowadzenie i cele testowania
2. Zakres testów
3. Typy testów do przeprowadzenia (np. testy jednostkowe, integracyjne, wydajnościowe)
4. Scenariusze testowe dla kluczowych funkcjonalności
5. Środowisko testowe
6. Narzędzia do testowania
7. Harmonogram testów
8. Kryteria akceptacji testów
9. Role i odpowiedzialności w procesie testowania
10. Procedury raportowania błędów

Pamiętaj, aby plan testów był:

- Dokładnie dostosowany do kontekstu projektu
- Uwzględniał specyfikę wykorzystywanych technologii
- Priorytetyzował kluczowe elementy repozytorium
- Był napisany w języku polskim
- Prezentował wysoką jakość i profesjonalizm

Rozpocznij od analizy, a następnie przejdź do tworzenia planu testów. Twój końcowy wynik powinien składać się tylko z planu testów i nie powinien powielać ani streszczać żadnej pracy wykonanej w bloku analizy projektu.

Przedstaw ten plan w formacie Markdown.
